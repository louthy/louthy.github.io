<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>LanguageExt.Core/Concurrency</title>
<link href="style.css" rel="stylesheet" type="text/css"/></head>
<body class="js-enabled"><div id="package-header"><ul class="links" id="page-menu"><li><a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency" class="link">Source</a></li>
<li><a href="../index.html" class="link">Contents</a></li>
<li><a href="../../index.html" class="link">Index</a></li></ul>
<p class="caption">LanguageExt.Core</p></div>
<div id="content"><div id="module-header"><p class="caption"><a href="../index.html" class="link">LanguageExt.Core</a>
<span> â–º </span>
<a href="index.html" class="link">Concurrency</a></p></div>
<p>We prefer to work with immutable types in functional-programming.  However, it's not always possible, and sometimes we
need some shared mutable state.  With the immutable types in this library you'd need to protect the updates with locks:</p>
<pre class='language-csharp'><code>// Some global
static HashSet&lt;int&gt; set = HashSet(1, 2, 3);
static object sync = new();

lock(sync)
{
    set = set.Add(4);
}
</code></pre>
<p>This in unsatisfactory, and so this module is all about lock-free atomic operations.  <code>Atom</code> allows you to protect any
value.  <code>AtomHashMap</code> and <code>AtomSeq</code> are <code>HashMap</code> and <code>Seq</code> wrapped up into a lock-free mutable structure.  Snapshots
of those are free!  The above code can be written:</p>
<pre class='language-csharp'><code>static AtomHashSet&lt;int&gt; set = AtomHashSet(1, 2, 3);
set.Add(4);
</code></pre>
<p>Finally, there's the Software Transactional Memory (STM) system.  Which allows for transactional changes to multiple
<code>Ref</code> values.  <code>Ref</code> just wrap up access to a value, and allows the state changes to be tracked by the <code>STM</code>.</p>
<p>See the <a href="https://github.com/louthy/language-ext/wiki/Concurrency">concurrency section</a> of the wiki for more info.</p>

<div id="table-of-contents"><p class="caption">Contents</p>
<ul><li><a href="#LanguageExt_0_LastWriteWins_1" class="link"><div class="nowrap">LastWriteWins
<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span></div></a></li>
<ul><li><a href="#LastWriteWins_1_Resolve_0" class="link"><div class="nowrap">Resolve

<span class='parens'>(</span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Current<span class='comma'>, </span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Proposed<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_FirstWriteWins_1" class="link"><div class="nowrap">FirstWriteWins
<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span></div></a></li>
<ul><li><a href="#FirstWriteWins_1_Resolve_0" class="link"><div class="nowrap">Resolve

<span class='parens'>(</span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Current<span class='comma'>, </span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Proposed<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_Conflict_1" class="link"><div class="nowrap">Conflict
<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span></div></a></li>
<ul></ul>
<li><a href="#LanguageExt_0_Prelude_0" class="link"><div class="nowrap">Prelude
</div></a></li>
<ul><li><a href="#Prelude_0_Ref_1" class="link"><div class="nowrap">Ref
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>A value<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>bool<span class='generics'>&gt;</span> validator = null<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_1" class="link"><div class="nowrap">atomic
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_1" class="link"><div class="nowrap">atomic
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_2" class="link"><div class="nowrap">atomic
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_1" class="link"><div class="nowrap">atomic
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_2" class="link"><div class="nowrap">atomic
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_1" class="link"><div class="nowrap">atomic
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_0" class="link"><div class="nowrap">atomic

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_1" class="link"><div class="nowrap">atomic
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_0" class="link"><div class="nowrap">atomic

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_0" class="link"><div class="nowrap">atomic

<span class='parens'>(</span>Action op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_1" class="link"><div class="nowrap">snapshot
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_1" class="link"><div class="nowrap">snapshot
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_2" class="link"><div class="nowrap">snapshot
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_1" class="link"><div class="nowrap">snapshot
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_2" class="link"><div class="nowrap">snapshot
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_1" class="link"><div class="nowrap">snapshot
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_0" class="link"><div class="nowrap">snapshot

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_1" class="link"><div class="nowrap">snapshot
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_0" class="link"><div class="nowrap">snapshot

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_0" class="link"><div class="nowrap">snapshot

<span class='parens'>(</span>Action op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_1" class="link"><div class="nowrap">serial
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_1" class="link"><div class="nowrap">serial
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_2" class="link"><div class="nowrap">serial
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_1" class="link"><div class="nowrap">serial
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_2" class="link"><div class="nowrap">serial
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_1" class="link"><div class="nowrap">serial
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_0" class="link"><div class="nowrap">serial

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_1" class="link"><div class="nowrap">serial
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_0" class="link"><div class="nowrap">serial

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_0" class="link"><div class="nowrap">serial

<span class='parens'>(</span>Action op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_1" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAsync_1" class="link"><div class="nowrap">swapAsync
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_1" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_1" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_2" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_2" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_2" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>A<span class='comma'>, </span>X<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAsync_2" class="link"><div class="nowrap">swapAsync
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_2" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_2" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_3" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_3" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_3" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>A<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAsync_3" class="link"><div class="nowrap">swapAsync
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_3" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_3" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_4" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_4" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_commute_1" class="link"><div class="nowrap">commute
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_commute_2" class="link"><div class="nowrap">commute
<span class='generics'>&lt;</span>A<span class='comma'>, </span>X<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_commute_3" class="link"><div class="nowrap">commute
<span class='generics'>&lt;</span>A<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_Atom_1" class="link"><div class="nowrap">Atom
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>A value<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_Atom_1" class="link"><div class="nowrap">Atom
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>A value<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>bool<span class='generics'>&gt;</span> validator<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_Atom_2" class="link"><div class="nowrap">Atom
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>M metadata<span class='comma'>, </span>A value<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_Atom_2" class="link"><div class="nowrap">Atom
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>M metadata<span class='comma'>, </span>A value<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>bool<span class='generics'>&gt;</span> validator<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_1" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_1" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_2" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAsync_1" class="link"><div class="nowrap">swapAsync
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_1" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_1" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_2" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_2" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_2" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_3" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAsync_2" class="link"><div class="nowrap">swapAsync
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_2" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_2" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_3" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_3" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_3" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_4" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAsync_3" class="link"><div class="nowrap">swapAsync
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_3" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_3" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_4" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_2" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_2" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_3" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAsync_2" class="link"><div class="nowrap">swapAsync
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_2" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_2" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_3" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_3" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_3" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_4" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAsync_3" class="link"><div class="nowrap">swapAsync
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_3" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_3" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_4" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_4" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_4" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_5" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAsync_4" class="link"><div class="nowrap">swapAsync
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_4" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>M<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_4" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>M<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_5" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li></ul></ul></div>
<div class="interface"><H1>Sub modules</H1>
<table><tbody><tr><td class="src clearfix"><span class="inst-left"><a href="Atom/index.html" class="link">Atom</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="AtomHashMap/index.html" class="link">AtomHashMap</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="AtomQue/index.html" class="link">AtomQue</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="AtomSeq/index.html" class="link">AtomSeq</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="STM/index.html" class="link">STM</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="Task/index.html" class="link">Task</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="ValueTask/index.html" class="link">ValueTask</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="VectorClock/index.html" class="link">VectorClock</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="VersionHashMap/index.html" class="link">VersionHashMap</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="VersionVector/index.html" class="link">VersionVector</a></span></td></tr></tbody></table>
<div class="top"><p class="src"><span class="keyword">struct</span>
<a id="LanguageExt_0_LastWriteWins_1" class="def">LastWriteWins</a>
<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Conflict.cs#L15" class="link">Source</a>
<a href="#LanguageExt_0_LastWriteWins_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Last-write-wins conflict resolver</p>
</div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
(long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value)
<a id="LastWriteWins_1_Resolve_0" class="def">Resolve</a>

<span class='parens'>(</span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Current<span class='comma'>, </span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Proposed<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Conflict.cs#L17" class="link">Source</a>
<a href="#LastWriteWins_1_Resolve_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">struct</span>
<a id="LanguageExt_0_FirstWriteWins_1" class="def">FirstWriteWins</a>
<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Conflict.cs#L26" class="link">Source</a>
<a href="#LanguageExt_0_FirstWriteWins_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>First-write-wins conflict resolver</p>
</div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
(long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value)
<a id="FirstWriteWins_1_Resolve_0" class="def">Resolve</a>

<span class='parens'>(</span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Current<span class='comma'>, </span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Proposed<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Conflict.cs#L28" class="link">Source</a>
<a href="#FirstWriteWins_1_Resolve_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">interface</span>
<a id="LanguageExt_0_Conflict_1" class="def">Conflict</a>
<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Conflict.cs#L7" class="link">Source</a>
<a href="#LanguageExt_0_Conflict_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Trait that defines how to deal with a conflict between two values</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">V</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Value type</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_Prelude_0" class="def">Prelude</a>

<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L8" class="link">Source</a>
<a href="#LanguageExt_0_Prelude_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_Ref_1" class="def">Ref</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>A value<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>bool<span class='generics'>&gt;</span> validator = null<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L70" class="link">Source</a>
<a href="#Prelude_0_Ref_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Generates a new reference that can be used within a <code>sync</code> transaction</p>
<p><code>Refs</code> ensure safe shared use of mutable storage locations via a software transactional
memory (STM) system. <code>Refs</code> are bound to a single storage location for their lifetime,
and only allow mutation of that location to occur within a transaction.</p>
</div>
<div><p>Transactions (within a <code>sync(() =&gt; ...)</code>) should be easy to understand if youâ€™ve ever used database
transactions - they ensure that all actions on Refs are atomic, consistent, and isolated.</p>
<ul>
<li class='markdown-bullet'><strong>Atomic</strong> - means that every change to Refs made within a transaction occurs or none do.</li>
<li class='markdown-bullet'><strong>Consistent</strong> - means that each new value can be checked with a validator function before allowing
the transaction to commit.</li>
<li class='markdown-bullet'><strong>Isolated</strong> - means that no transaction sees the effects of any other transaction while it is
running.</li>
</ul>
<p>Another feature common to STMs is that, should a transaction have a conflict while running,
it is automatically retried.  The language-ext STM uses multi-version concurrency control for
snapshot and serialisable isolation.</p>
<p>In practice, this means:</p>
<p>All reads of Refs will see a consistent snapshot of the <em>Ref world</em> as of the starting point
of the transaction (its 'read point'). The transaction will see any changes it has made.
This is called the in-transaction-value.</p>
<p>All changes made to Refs during a transaction will appear to occur at a single point in the
<em>Ref world</em> timeline (its 'write point').</p>
<p>No changes will have been made by any other transactions to any Refs that have been modified
by this transaction.</p>
<ul>
<li class='markdown-bullet'><p>Readers will never block writers, or other readers.</p>
</li>
<li class='markdown-bullet'><p>Writers will never block readers.</p>
</li>
</ul>
<p>I/O and other activities with side-effects should be avoided in transactions, since transactions
will be retried.</p>
<p>If a constraint on the validity of a value of a Ref that is being changed depends upon the
simultaneous value of a Ref that is not being changed, that second Ref can be protected from
modification by running the <code>sync</code> transaction with <code>Isolation.Serialisable</code>.</p>
<p>The language-ext STM is designed to work with the persistent collections (<code>Map</code>, <code>HashMap</code>,
<code>Seq</code>, <code>Lst</code>, <code>Set, </code>HashSet` etc.), and it is strongly recommended that you use the language-ext
collections as the values of your Refs. Since all work done in an STM transaction is speculative,
it is imperative that there be a low cost to making copies and modifications. Persistent collections
have free copies (just use the original, it canâ€™t be changed), and 'modifications' share structure
efficiently. In any case:</p>
<p>The values placed in Refs must be, or be considered, <strong>immutable</strong>. Otherwise, this library canâ€™t help you.</p>

<p>See the <a href="https://github.com/louthy/language-ext/wiki/Concurrency">concurrency section</a> of the wiki for more info.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">value</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Initial value of the ref</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">validator</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Validator that is called on the ref value just
before any transaction is committed (within a <code>sync</code>)</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
R
<a id="Prelude_0_atomic_1" class="def">atomic</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L106" class="link">Source</a>
<a href="#Prelude_0_atomic_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_atomic_1" class="def">atomic</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L142" class="link">Source</a>
<a href="#Prelude_0_atomic_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_atomic_2" class="def">atomic</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L178" class="link">Source</a>
<a href="#Prelude_0_atomic_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_atomic_1" class="def">atomic</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L214" class="link">Source</a>
<a href="#Prelude_0_atomic_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_atomic_2" class="def">atomic</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L250" class="link">Source</a>
<a href="#Prelude_0_atomic_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_atomic_1" class="def">atomic</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L286" class="link">Source</a>
<a href="#Prelude_0_atomic_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Unit<span class='generics'>&gt;</span>
<a id="Prelude_0_atomic_0" class="def">atomic</a>

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L322" class="link">Source</a>
<a href="#Prelude_0_atomic_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_atomic_1" class="def">atomic</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L358" class="link">Source</a>
<a href="#Prelude_0_atomic_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>Unit<span class='generics'>&gt;</span>
<a id="Prelude_0_atomic_0" class="def">atomic</a>

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L394" class="link">Source</a>
<a href="#Prelude_0_atomic_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Unit
<a id="Prelude_0_atomic_0" class="def">atomic</a>

<span class='parens'>(</span>Action op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L430" class="link">Source</a>
<a href="#Prelude_0_atomic_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
R
<a id="Prelude_0_snapshot_1" class="def">snapshot</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L444" class="link">Source</a>
<a href="#Prelude_0_snapshot_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_snapshot_1" class="def">snapshot</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L457" class="link">Source</a>
<a href="#Prelude_0_snapshot_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_snapshot_2" class="def">snapshot</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L470" class="link">Source</a>
<a href="#Prelude_0_snapshot_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_snapshot_1" class="def">snapshot</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L483" class="link">Source</a>
<a href="#Prelude_0_snapshot_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_snapshot_2" class="def">snapshot</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L497" class="link">Source</a>
<a href="#Prelude_0_snapshot_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_snapshot_1" class="def">snapshot</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L510" class="link">Source</a>
<a href="#Prelude_0_snapshot_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Unit<span class='generics'>&gt;</span>
<a id="Prelude_0_snapshot_0" class="def">snapshot</a>

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L523" class="link">Source</a>
<a href="#Prelude_0_snapshot_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_snapshot_1" class="def">snapshot</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L536" class="link">Source</a>
<a href="#Prelude_0_snapshot_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>Unit<span class='generics'>&gt;</span>
<a id="Prelude_0_snapshot_0" class="def">snapshot</a>

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L549" class="link">Source</a>
<a href="#Prelude_0_snapshot_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Unit
<a id="Prelude_0_snapshot_0" class="def">snapshot</a>

<span class='parens'>(</span>Action op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L562" class="link">Source</a>
<a href="#Prelude_0_snapshot_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
R
<a id="Prelude_0_serial_1" class="def">serial</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L594" class="link">Source</a>
<a href="#Prelude_0_serial_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_serial_1" class="def">serial</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L625" class="link">Source</a>
<a href="#Prelude_0_serial_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_serial_2" class="def">serial</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L656" class="link">Source</a>
<a href="#Prelude_0_serial_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_serial_1" class="def">serial</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L687" class="link">Source</a>
<a href="#Prelude_0_serial_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_serial_2" class="def">serial</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L718" class="link">Source</a>
<a href="#Prelude_0_serial_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_serial_1" class="def">serial</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L749" class="link">Source</a>
<a href="#Prelude_0_serial_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Unit<span class='generics'>&gt;</span>
<a id="Prelude_0_serial_0" class="def">serial</a>

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L780" class="link">Source</a>
<a href="#Prelude_0_serial_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_serial_1" class="def">serial</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L811" class="link">Source</a>
<a href="#Prelude_0_serial_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>Unit<span class='generics'>&gt;</span>
<a id="Prelude_0_serial_0" class="def">serial</a>

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L842" class="link">Source</a>
<a href="#Prelude_0_serial_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Unit
<a id="Prelude_0_serial_0" class="def">serial</a>

<span class='parens'>(</span>Action op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L873" class="link">Source</a>
<a href="#Prelude_0_serial_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre class='language-csharp'><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
A
<a id="Prelude_0_swap_1" class="def">swap</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L885" class="link">Source</a>
<a href="#Prelude_0_swap_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAsync_1" class="def">swapAsync</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L896" class="link">Source</a>
<a href="#Prelude_0_swapAsync_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_1" class="def">swapAff</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L907" class="link">Source</a>
<a href="#Prelude_0_swapAff_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_1" class="def">swapEff</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L918" class="link">Source</a>
<a href="#Prelude_0_swapEff_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_2" class="def">swapAff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L929" class="link">Source</a>
<a href="#Prelude_0_swapAff_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_2" class="def">swapEff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L940" class="link">Source</a>
<a href="#Prelude_0_swapEff_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
A
<a id="Prelude_0_swap_2" class="def">swap</a>
<span class='generics'>&lt;</span>A<span class='comma'>, </span>X<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L951" class="link">Source</a>
<a href="#Prelude_0_swap_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAsync_2" class="def">swapAsync</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L962" class="link">Source</a>
<a href="#Prelude_0_swapAsync_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_2" class="def">swapAff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L973" class="link">Source</a>
<a href="#Prelude_0_swapAff_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_2" class="def">swapEff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L984" class="link">Source</a>
<a href="#Prelude_0_swapEff_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_3" class="def">swapAff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L995" class="link">Source</a>
<a href="#Prelude_0_swapAff_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_3" class="def">swapEff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1006" class="link">Source</a>
<a href="#Prelude_0_swapEff_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
A
<a id="Prelude_0_swap_3" class="def">swap</a>
<span class='generics'>&lt;</span>A<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1017" class="link">Source</a>
<a href="#Prelude_0_swap_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAsync_3" class="def">swapAsync</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1028" class="link">Source</a>
<a href="#Prelude_0_swapAsync_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_3" class="def">swapAff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1039" class="link">Source</a>
<a href="#Prelude_0_swapAff_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_3" class="def">swapEff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1050" class="link">Source</a>
<a href="#Prelude_0_swapEff_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_4" class="def">swapAff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1061" class="link">Source</a>
<a href="#Prelude_0_swapAff_4" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_4" class="def">swapEff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1072" class="link">Source</a>
<a href="#Prelude_0_swapEff_4" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
A
<a id="Prelude_0_commute_1" class="def">commute</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1094" class="link">Source</a>
<a href="#Prelude_0_commute_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Must be called in a transaction. Sets the in-transaction-value of
ref to:</p>
<pre class='language-csharp'><code>`f(in-transaction-value-of-ref)`
</code></pre>
<p>and returns the in-transaction-value when complete.</p>
<p>At the commit point of the transaction, <code>f</code> is run <em>AGAIN</em> with the
most recently committed value:</p>
<pre class='language-csharp'><code>`f(most-recently-committed-value-of-ref)`
</code></pre>
<p>Thus <code>f</code> should be commutative, or, failing that, you must accept
last-one-in-wins behavior.</p>
<p>Commute allows for more concurrency than just setting the Ref's value</p>
</div>
<div></div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
A
<a id="Prelude_0_commute_2" class="def">commute</a>
<span class='generics'>&lt;</span>A<span class='comma'>, </span>X<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1116" class="link">Source</a>
<a href="#Prelude_0_commute_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Must be called in a transaction. Sets the in-transaction-value of
ref to:</p>
<pre class='language-csharp'><code>`f(in-transaction-value-of-ref)`
</code></pre>
<p>and returns the in-transaction-value when complete.</p>
<p>At the commit point of the transaction, <code>f</code> is run <em>AGAIN</em> with the
most recently committed value:</p>
<pre class='language-csharp'><code>`f(most-recently-committed-value-of-ref)`
</code></pre>
<p>Thus <code>f</code> should be commutative, or, failing that, you must accept
last-one-in-wins behavior.</p>
<p>Commute allows for more concurrency than just setting the Ref's value</p>
</div>
<div></div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
A
<a id="Prelude_0_commute_3" class="def">commute</a>
<span class='generics'>&lt;</span>A<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1138" class="link">Source</a>
<a href="#Prelude_0_commute_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Must be called in a transaction. Sets the in-transaction-value of
ref to:</p>
<pre class='language-csharp'><code>`f(in-transaction-value-of-ref)`
</code></pre>
<p>and returns the in-transaction-value when complete.</p>
<p>At the commit point of the transaction, <code>f</code> is run <em>AGAIN</em> with the
most recently committed value:</p>
<pre class='language-csharp'><code>`f(most-recently-committed-value-of-ref)`
</code></pre>
<p>Thus <code>f</code> should be commutative, or, failing that, you must accept
last-one-in-wins behavior.</p>
<p>Commute allows for more concurrency than just setting the Ref's value</p>
</div>
<div></div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_Atom_1" class="def">Atom</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>A value<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1164" class="link">Source</a>
<a href="#Prelude_0_Atom_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atoms provide a way to manage shared, synchronous, independent state without
locks.</p>
</div>
<div><p>The intended use of atom is to hold one an immutable data structure. You change
the value by applying a function to the old value. This is done in an atomic
manner by <code>Swap</code>.</p>
<p>Internally, <code>Swap</code> reads the current value, applies the function to it, and
attempts to <code>CompareExchange</code> it in. Since another thread may have changed the
value in the intervening time, it may have to retry, and does so in a spin loop.</p>
<p>The net effect is that the value will always be the result of the application
of the supplied function to a current value, atomically. However, because the
function might be called multiple times, it must be free of side effects.</p>
<p>Atoms are an efficient way to represent some state that will never need to be
coordinated with any other, and for which you wish to make synchronous changes.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">value</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Initial value of the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The constructed Atom</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="Prelude_0_Atom_1" class="def">Atom</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>A value<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>bool<span class='generics'>&gt;</span> validator<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1197" class="link">Source</a>
<a href="#Prelude_0_Atom_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atoms provide a way to manage shared, synchronous, independent state without
locks.</p>
</div>
<div><p>The intended use of atom is to hold one an immutable data structure. You change
the value by applying a function to the old value. This is done in an atomic
manner by <code>Swap</code>.</p>
<p>Internally, <code>Swap</code> reads the current value, applies the function to it, and
attempts to <code>CompareExchange</code> it in. Since another thread may have changed the
value in the intervening time, it may have to retry, and does so in a spin loop.</p>
<p>The net effect is that the value will always be the result of the application
of the supplied function to a current value, atomically. However, because the
function might be called multiple times, it must be free of side effects.</p>
<p>Atoms are an efficient way to represent some state that will never need to be
coordinated with any other, and for which you wish to make synchronous changes.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">value</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Initial value of the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">validator</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to run on the value after each state change.</p>
<p>If the function returns false for any proposed new state, then the <code>swap</code>
function will return <code>false</code>, else it will return <code>true</code> on successful setting
of the atom's state</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The constructed Atom or None if the validation faled for the initial
<code>value</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_Atom_2" class="def">Atom</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>M metadata<span class='comma'>, </span>A value<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1224" class="link">Source</a>
<a href="#Prelude_0_Atom_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atoms provide a way to manage shared, synchronous, independent state without
locks.</p>
</div>
<div><p>The intended use of atom is to hold one an immutable data structure. You change
the value by applying a function to the old value. This is done in an atomic
manner by <code>Swap</code>.</p>
<p>Internally, <code>Swap</code> reads the current value, applies the function to it, and
attempts to <code>CompareExchange</code> it in. Since another thread may have changed the
value in the intervening time, it may have to retry, and does so in a spin loop.</p>
<p>The net effect is that the value will always be the result of the application
of the supplied function to a current value, atomically. However, because the
function might be called multiple times, it must be free of side effects.</p>
<p>Atoms are an efficient way to represent some state that will never need to be
coordinated with any other, and for which you wish to make synchronous changes.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">metadata</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Metadata to be passed to the validation function</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">value</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Initial value of the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The constructed Atom</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="Prelude_0_Atom_2" class="def">Atom</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>M metadata<span class='comma'>, </span>A value<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>bool<span class='generics'>&gt;</span> validator<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1258" class="link">Source</a>
<a href="#Prelude_0_Atom_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atoms provide a way to manage shared, synchronous, independent state without
locks.</p>
</div>
<div><p>The intended use of atom is to hold one an immutable data structure. You change
the value by applying a function to the old value. This is done in an atomic
manner by <code>Swap</code>.</p>
<p>Internally, <code>Swap</code> reads the current value, applies the function to it, and
attempts to <code>CompareExchange</code> it in. Since another thread may have changed the
value in the intervening time, it may have to retry, and does so in a spin loop.</p>
<p>The net effect is that the value will always be the result of the application
of the supplied function to a current value, atomically. However, because the
function might be called multiple times, it must be free of side effects.</p>
<p>Atoms are an efficient way to represent some state that will never need to be
coordinated with any other, and for which you wish to make synchronous changes.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">metadata</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Metadata to be passed to the validation function</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">value</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Initial value of the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">validator</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to run on the value after each state change.</p>
<p>If the function returns false for any proposed new state, then the <code>swap</code>
function will return <code>false</code>, else it will return <code>true</code> on successful setting
of the atom's state</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The constructed Atom or None if the validation faled for the initial
<code>value</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swap_1" class="def">swap</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1270" class="link">Source</a>
<a href="#Prelude_0_swap_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_1" class="def">swapEff</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1282" class="link">Source</a>
<a href="#Prelude_0_swapEff_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_2" class="def">swapEff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1293" class="link">Source</a>
<a href="#Prelude_0_swapEff_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="Prelude_0_swapAsync_1" class="def">swapAsync</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1304" class="link">Source</a>
<a href="#Prelude_0_swapAsync_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_1" class="def">swapAff</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1315" class="link">Source</a>
<a href="#Prelude_0_swapAff_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_1" class="def">swapAff</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1326" class="link">Source</a>
<a href="#Prelude_0_swapAff_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_2" class="def">swapAff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1337" class="link">Source</a>
<a href="#Prelude_0_swapAff_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swap_2" class="def">swap</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1349" class="link">Source</a>
<a href="#Prelude_0_swap_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_2" class="def">swapEff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1361" class="link">Source</a>
<a href="#Prelude_0_swapEff_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_3" class="def">swapEff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1373" class="link">Source</a>
<a href="#Prelude_0_swapEff_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="Prelude_0_swapAsync_2" class="def">swapAsync</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1385" class="link">Source</a>
<a href="#Prelude_0_swapAsync_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_2" class="def">swapAff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1397" class="link">Source</a>
<a href="#Prelude_0_swapAff_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_2" class="def">swapAff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1409" class="link">Source</a>
<a href="#Prelude_0_swapAff_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_3" class="def">swapAff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1421" class="link">Source</a>
<a href="#Prelude_0_swapAff_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swap_3" class="def">swap</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1434" class="link">Source</a>
<a href="#Prelude_0_swap_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_3" class="def">swapEff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1447" class="link">Source</a>
<a href="#Prelude_0_swapEff_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_4" class="def">swapEff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1460" class="link">Source</a>
<a href="#Prelude_0_swapEff_4" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="Prelude_0_swapAsync_3" class="def">swapAsync</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1473" class="link">Source</a>
<a href="#Prelude_0_swapAsync_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_3" class="def">swapAff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1486" class="link">Source</a>
<a href="#Prelude_0_swapAff_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_3" class="def">swapAff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1499" class="link">Source</a>
<a href="#Prelude_0_swapAff_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_4" class="def">swapAff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1512" class="link">Source</a>
<a href="#Prelude_0_swapAff_4" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swap_2" class="def">swap</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1524" class="link">Source</a>
<a href="#Prelude_0_swap_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_2" class="def">swapEff</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1535" class="link">Source</a>
<a href="#Prelude_0_swapEff_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_3" class="def">swapEff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1546" class="link">Source</a>
<a href="#Prelude_0_swapEff_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="Prelude_0_swapAsync_2" class="def">swapAsync</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1557" class="link">Source</a>
<a href="#Prelude_0_swapAsync_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_2" class="def">swapAff</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1568" class="link">Source</a>
<a href="#Prelude_0_swapAff_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_2" class="def">swapAff</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1579" class="link">Source</a>
<a href="#Prelude_0_swapAff_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_3" class="def">swapAff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1590" class="link">Source</a>
<a href="#Prelude_0_swapAff_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swap_3" class="def">swap</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1602" class="link">Source</a>
<a href="#Prelude_0_swap_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_3" class="def">swapEff</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1614" class="link">Source</a>
<a href="#Prelude_0_swapEff_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_4" class="def">swapEff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1626" class="link">Source</a>
<a href="#Prelude_0_swapEff_4" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="Prelude_0_swapAsync_3" class="def">swapAsync</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1638" class="link">Source</a>
<a href="#Prelude_0_swapAsync_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_3" class="def">swapAff</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1650" class="link">Source</a>
<a href="#Prelude_0_swapAff_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_3" class="def">swapAff</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1662" class="link">Source</a>
<a href="#Prelude_0_swapAff_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_4" class="def">swapAff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1674" class="link">Source</a>
<a href="#Prelude_0_swapAff_4" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swap_4" class="def">swap</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1687" class="link">Source</a>
<a href="#Prelude_0_swap_4" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_4" class="def">swapEff</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1700" class="link">Source</a>
<a href="#Prelude_0_swapEff_4" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_5" class="def">swapEff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1713" class="link">Source</a>
<a href="#Prelude_0_swapEff_5" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="Prelude_0_swapAsync_4" class="def">swapAsync</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1726" class="link">Source</a>
<a href="#Prelude_0_swapAsync_4" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_4" class="def">swapAff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>M<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1739" class="link">Source</a>
<a href="#Prelude_0_swapAff_4" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_4" class="def">swapAff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>M<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1752" class="link">Source</a>
<a href="#Prelude_0_swapAff_4" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_5" class="def">swapAff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/v4-latest/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1765" class="link">Source</a>
<a href="#Prelude_0_swapAff_5" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div></div></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-core.min.js" integrity="sha512-9khQRAUBYEJDCDVP2yw3LRUQvjJ0Pjx0EShmaQjcHa6AXiOv6qHQu9lCAIR8O+/D8FtaCoJ2c0Tf9Xo7hYH01Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-fTl/qcO1VgvKtOMApX2PdZzkziyr2stM65GYPLGuYMnuMm1z2JLJG6XVU7C/mR+E7xBUqCivykuhlzfqxXBXbg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script></body></html>