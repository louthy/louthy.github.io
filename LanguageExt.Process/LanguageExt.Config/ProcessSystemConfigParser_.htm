<html ><head ><link rel="stylesheet" type="text/css" href="doc.css"></link></head><body ><div class="nav-bar"><a class="nav-bar-link" href="https://louthy.github.io/">API Reference</a> \ <a class="nav-bar-link" href="../LanguageExt.Config/index.htm">LanguageExt.Config</a> \ <span class="nav-bar-link" href="ProcessSystemConfigParser_.htm">ProcessSystemConfigParser</span></div><div class="nav-panel"><h3 >CONSTRUCTORS</h3><a class="nav-link" href="#ProcessSystemConfigParser">ProcessSystemConfigParser(string, Types, IEnumerable&lt;FuncSpec&gt;)</a><h3 >FIELDS</h3><a class="nav-link" href="#argument">argument</a><a class="nav-link" href="#argumentMany">argumentMany</a><a class="nav-link" href="#arguments">arguments</a><a class="nav-link" href="#clusterType">clusterType</a><a class="nav-link" href="#Definition">Definition</a><a class="nav-link" href="#expr">expr</a><a class="nav-link" href="#exprUnknownType">exprUnknownType</a><a class="nav-link" href="#floating">floating</a><a class="nav-link" href="#identifier">identifier</a><a class="nav-link" href="#integer">integer</a><a class="nav-link" href="#match">match</a><a class="nav-link" href="#namedArgument">namedArgument</a><a class="nav-link" href="#natural">natural</a><a class="nav-link" href="#nodeName">nodeName</a><a class="nav-link" href="#parser">parser</a><a class="nav-link" href="#processId">processId</a><a class="nav-link" href="#processName">processName</a><a class="nav-link" href="#processType">processType</a><a class="nav-link" href="#redirect">redirect</a><a class="nav-link" href="#reserved">reserved</a><a class="nav-link" href="#reservedOp">reservedOp</a><a class="nav-link" href="#routerType">routerType</a><a class="nav-link" href="#strategyType">strategyType</a><a class="nav-link" href="#stringLiteral">stringLiteral</a><a class="nav-link" href="#symbol">symbol</a><a class="nav-link" href="#term">term</a><a class="nav-link" href="#TokenParser">TokenParser</a><a class="nav-link" href="#types">types</a><a class="nav-link" href="#valueDef">valueDef</a><a class="nav-link" href="#valueUntyped">valueUntyped</a><a class="nav-link" href="#whiteSpace">whiteSpace</a><h3 >METHODS</h3><a class="nav-link" href="#brackets&lt;T>">brackets&lt;T&gt;(Parser&lt;T&gt;)</a><a class="nav-link" href="#commaSep&lt;T>">commaSep&lt;T&gt;(Parser&lt;T&gt;)</a><a class="nav-link" href="#commaSep1&lt;T>">commaSep1&lt;T&gt;(Parser&lt;T&gt;)</a><a class="nav-link" href="#parens&lt;T>">parens&lt;T&gt;(Parser&lt;T&gt;)</a><a class="nav-link" href="#ParseConfigText">ParseConfigText(string)</a><a class="nav-link" href="#token&lt;T>">token&lt;T&gt;(Parser&lt;T&gt;)</a></div><div class="content-panel"><h1 >ProcessSystemConfigParser Class</h1><p ><span >Parses the Process system conf file format This is a bit more advanced than your usual configuration format, in that it&#39;s essentially a statically typed programming language.   </span></p><div class="left"><div class="section"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">class</span> <span class="ident">ProcessSystemConfigParser</span></div></div></div><div class="right"><div class="section"><div class="section_title">NAMESPACE</div>LanguageExt.Config</div></div><h2 >Constructors</h2><div class="member-title"><a name="ProcessSystemConfigParser"></a>ProcessSystemConfigParser(string, Types, IEnumerable&lt;FuncSpec&gt;)<div class="source-link-cont"><a class="source-link" href="#" onclick="document.getElementById(&#39;code-ProcessSystemConfigParser__string__nodeName__Types__typeDefs__IEnumerable_FuncSpec_strategyFuncs_&#39;).style.display=&#39;&#39;;">SOURCE</a></div></div><div class="section"><div class="left"><div class="section_title">PARAMETERS</div><div class="arg"><div class="arg-header"><div class="arg-name">nodeName</div><div class="arg-type"><span class="keyword">string</span></div></div></div><div class="arg"><div class="arg-header"><div class="arg-name">typeDefs</div><div class="arg-type"><span class="ident">Types</span></div></div></div><div class="arg"><div class="arg-header"><div class="arg-name">strategyFuncs</div><div class="arg-type"><span class="ident">IEnumerable</span>&lt;<span class="ident">FuncSpec</span>&gt;</div></div></div></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">ctor</span> <span class="ident">ProcessSystemConfigParser</span>(<span class="keyword">string</span> nodeName, <span class="ident">Types</span> typeDefs, <span class="ident">IEnumerable</span>&lt;<span class="ident">FuncSpec</span>&gt; strategyFuncs)</div></div><div style="display:none" id="code-ProcessSystemConfigParser__string__nodeName__Types__typeDefs__IEnumerable_FuncSpec_strategyFuncs_"><div class="section_title">SOURCE</div><div class="code">
            strategyFuncs        = strategyFuncs ?? new FuncSpec[0];
            this.nodeName        = nodeName;
            this.types           = typeDefs;
            this.clusterType     = types.Register(BuildClusterType());
            this.processType     = types.Register(BuildProcessType());
            this.routerType      = types.Register(BuildRouterType());
            this.strategyType    = types.Register(BuildStrategySpec(types, strategyFuncs));

            var opChars = &quot;:!%&amp;*+.&lt;=&gt;\\^|-~&quot;;

            // Process config definition
            Definition = GenLanguageDef.Empty.With(
                CommentStart: &quot;/*&quot;,
                CommentEnd: &quot;*/&quot;,
                CommentLine: &quot;//&quot;,
                NestedComments: true,
                OpStart: oneOf(opChars),
                OpLetter: oneOf(opChars),
                IdentStart: letter,
                IdentLetter: either(alphaNum, oneOf(&quot;-_&quot;)),
                ReservedNames: List(&quot;if&quot;, &quot;then&quot;, &quot;else&quot;).AddRange(types.AllInOrder.Map(t =&gt; t.Name)),
                ReservedOpNames: List(&quot;-&quot;, &quot;+&quot;, &quot;/&quot;, &quot;*&quot;, &quot;==&quot;, &quot;!=&quot;, &quot;&gt;&quot;, &quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot;, &quot;||&quot;, &quot;&amp;&amp;&quot;, &quot;|&quot;, &quot;&amp;&quot;, &quot;%&quot;, &quot;!&quot;, &quot;~&quot;, &quot;^&quot;)
            );

            // Token parser
            // This builds the standard token parser from the definition above
            TokenParser   = makeTokenParser(Definition);
            identifier    = TokenParser.Identifier;
            stringLiteral = TokenParser.StringLiteral;
            integer       = TokenParser.Integer;
            floating      = TokenParser.Float;
            natural       = TokenParser.Natural;
            whiteSpace    = TokenParser.WhiteSpace;
            symbol        = TokenParser.Symbol;
            reserved      = TokenParser.Reserved;
            reservedOp    = TokenParser.ReservedOp;

            // Binary operator parser
            Func&lt;string, Assoc, Operator&lt;ValueToken&gt;&gt; binary =
                (name, assoc) =&gt;
                     Operator.Infix(assoc,
                        from x in reservedOp(name)
                        select ValueToken.BinaryOp(name));

            // Prefix operator parser
            Func&lt;string, Operator&lt;ValueToken&gt;&gt; prefix =
                (name) =&gt;
                    Operator.Prefix(
                        from x in reservedOp(name)
                        select ValueToken.PrefixOp(name));

            // Postfix operator parser
            Func&lt;string, Operator&lt;ValueToken&gt;&gt; postfix =
                (name) =&gt;
                    Operator.Postfix(
                        from x in reservedOp(name)
                        select ValueToken.PostfixOp(name));

            // Operator table
            Operator&lt;ValueToken&gt;[][] table = {
                new [] { prefix(&quot;-&quot;), prefix(&quot;+&quot;), prefix(&quot;!&quot;) },
                new [] { binary(&quot;*&quot;, Assoc.Left), binary(&quot;/&quot;, Assoc.Left), binary(&quot;%&quot;, Assoc.Left) },
                new [] { binary(&quot;+&quot;, Assoc.Left), binary(&quot;-&quot;, Assoc.Left) },
                new [] { binary(&quot;&lt;&quot;, Assoc.Left), binary(&quot;&gt;&quot;, Assoc.Left), binary(&quot;&gt;=&quot;, Assoc.Left) , binary(&quot;&lt;=&quot;, Assoc.Left) },
                new [] { binary(&quot;==&quot;, Assoc.Left), binary(&quot;!=&quot;, Assoc.Left) },
                new [] { binary(&quot;&amp;&quot;, Assoc.Left) },
                new [] { binary(&quot;^&quot;, Assoc.Left) },
                new [] { binary(&quot;|&quot;, Assoc.Left) },
                new [] { binary(&quot;&amp;&amp;&quot;, Assoc.Left) },
                new [] { binary(&quot;||&quot;, Assoc.Left) },
            };


            Func&lt;Option&lt;string&gt;, TypeDef, Parser&lt;ValueToken&gt;&gt; valueInst = null;
            Parser&lt;TypeDef&gt; typeName = null;

            // ProcessId parser
            processId =
                token(
                    from xs in many1(choice(lower, digit, oneOf(&quot;@/[,-_]{}: &quot;)))
                    let r = (new string(xs.ToArray())).Trim()
                    let pid = ProcessId.TryParse(r)
                    from res in pid.Match(
                        Right: x =&gt; result(x),
                        Left: ex =&gt; failure&lt;ProcessId&gt;($&quot;{ex.Message} &#39;({r})&#39;&quot;))
                    select res);

            // ProcessName parser
            processName =
                token(
                    from o in symbol(&quot;\&quot;&quot;)
                    from xs in many1(choice(lower, digit, oneOf(&quot;@/[,-_]{.}: &quot;)))
                    from c in symbol(&quot;\&quot;&quot;)
                    let r = (new string(xs.ToArray())).Trim()
                    let n = ProcessName.TryParse(r)
                    from res in n.Match(
                        Right: x =&gt; result(x),
                        Left: ex =&gt; failure&lt;ProcessName&gt;(ex.Message))
                    select res);

            // Attribute parser
            Func&lt;string, Parser&lt;ValueToken&gt;, Parser&lt;NamedValueToken&gt;&gt; attr =
                (name, p) =&gt;
                    from x in reserved(name)
                    from _ in symbol(&quot;=&quot;)
                    from v in p
                    select new NamedValueToken(name,v,None);

            // Type name parser
            Parser&lt;Type&gt; type =
                from x in letter
                from xs in many1(choice(letter, ch(&#39;.&#39;), ch(&#39;_&#39;)))
                select Type.GetType(new string(x.Cons(xs).ToArray()));

            var directive = types.Directive.ValueParser(this).Map(x =&gt; (Directive)x);
            var msgDirective = types.MessageDirective.ValueParser(this).Map(x =&gt; (MessageDirective)x);

            Parser&lt;State&lt;Exception, Option&lt;Directive&gt;&gt;&gt; exceptionDirective =
                from b in symbol(&quot;|&quot;)
                from t in token(type)
                from a in symbol(&quot;-&gt;&quot;)
                from d in directive
                select Strategy.With(d, t);

            Parser&lt;State&lt;Exception, Option&lt;Directive&gt;&gt;&gt; otherwiseDirective =
                from b in symbol(&quot;|&quot;)
                from t in symbol(&quot;_&quot;)
                from a in symbol(&quot;-&gt;&quot;)
                from d in directive
                select Strategy.Otherwise(d);

            Parser&lt;State&lt;Directive, Option&lt;MessageDirective&gt;&gt;&gt; matchMessageDirective =
                from b in symbol(&quot;|&quot;)
                from d in token(directive)
                from a in symbol(&quot;-&gt;&quot;)
                from m in token(msgDirective)
                select Strategy.When(m, d);

            Parser&lt;State&lt;Directive, Option&lt;MessageDirective&gt;&gt;&gt; otherwiseMsgDirective =
                from b in symbol(&quot;|&quot;)
                from t in symbol(&quot;_&quot;)
                from a in symbol(&quot;-&gt;&quot;)
                from d in token(msgDirective)
                select Strategy.Otherwise(d);

            // Strategy exception -&gt; directive parser
            match =
                from _ in attempt(reserved(&quot;match&quot;))
                from direx in many(attempt(exceptionDirective))
                from other in optional(otherwiseDirective)
                let dirs = direx.Append(other.AsEnumerable()).ToArray()
                from ok in dirs.Length &gt; 0
                    ? result(dirs)
                    : failure&lt;State&lt;Exception, Option&lt;Directive&gt;&gt;[]&gt;(&quot;&#39;match&#39; must be followed by at least one clause&quot;)
                select new ValueToken(types.Get(&quot;strategy&quot;), Strategy.Match(dirs));

            Parser&lt;State&lt;StrategyContext, Unit&gt;&gt; redirectMatch =
                from direx in many(attempt(matchMessageDirective))
                from other in optional(otherwiseMsgDirective)
                let dirs = direx.Append(other.AsEnumerable()).ToArray()
                from ok in dirs.Length &gt; 0
                    ? result(dirs)
                    : failure&lt;State&lt;Directive, Option&lt;MessageDirective&gt;&gt;[]&gt;(&quot;&#39;redirect when&#39; must be followed by at least one clause&quot;)
                select Strategy.Redirect(dirs);

            // Strategy directive -&gt; message-directive matching parser
            redirect =
                from n in attempt(reserved(&quot;redirect&quot;))
                from t in either(attempt(symbol(&quot;:&quot;)), reserved(&quot;when&quot;))
                from r in t == &quot;:&quot;
                   ? from d in token(msgDirective)
                     select Strategy.Redirect(d)
                   : redirectMatch
                select new ValueToken(types.Get(&quot;strategy&quot;), r);

            // Type name parser
            typeName = choice(types.AllInOrder.Map(t =&gt; reserved(t.Name).Map(_ =&gt; t)).ToArray());

            // cluster.&lt;alias&gt;.&lt;property&gt; parser -- TODO: generalise
            Parser&lt;ValueToken&gt; clusterVar =
                attempt(
                    from _ in reserved(&quot;cluster&quot;)
                    from tup in either(
                        attempt(
                            from d1 in symbol(&quot;.&quot;)
                            from alias in identifier
                            from d2 in symbol(&quot;.&quot;)
                            from id in identifier
                            select Tuple(alias, id)),
                        attempt(
                            from d in symbol(&quot;.&quot;)
                            from id in identifier
                            select Tuple(&quot;&quot;,id)))
                    from sub in optional(from d2 in symbol(&quot;.&quot;)
                                         from id2 in identifier
                                         select id2).Map(x =&gt; x.IfNone(&quot;value&quot;))
                    from state in getState&lt;ParserState&gt;()                               // TODO: This can be generalised into an object walking system
                    from v in state.Clusters.Find(tup.Item1).Match(                     //       where an object (in this case the cluster), is in &#39;scope&#39;
                        Some: cluster =&gt;                                                //       and recursive walking of the dot operator will find the
                            cluster.Settings.Find(tup.Item2).Match(                     //       value.
                                Some: local =&gt; result(local),
                                None: () =&gt; failure&lt;ValueToken&gt;($&quot;unknown identifier &#39;cluster.{tup.Item2}&#39;&quot;)),
                        None: () =&gt; failure&lt;ValueToken&gt;($&quot;cluster.{tup.Item2} used when a cluster with a node-name attribute set to &#39;{nodeName}&#39; hasn&#39;t been defined.  Or the cluster called &#39;{nodeName}&#39; exists and is aliased, and you&#39;re not providing the variable in the form: cluster.&lt;alias&gt;.&lt;property-name&gt;&quot;))
                    select v
                );

            // Variable of unknown type parser
            Parser&lt;ValueToken&gt; variable =
                either(
                    clusterVar,
                    attempt(
                        from id in identifier
                        from state in getState&lt;ParserState&gt;()
                        from v in state.Local(id).Match(
                            Some: v =&gt; result(v),
                            None: () =&gt; failure&lt;ValueToken&gt;($&quot;unknown identifier &#39;{id}&#39; &quot;))
                        select v
                    )
                );

            // Variable of known type parser
            Func&lt;TypeDef, Parser&lt;ValueToken&gt;&gt; variableOfType =
                expect =&gt;
                    from v in variable
                    from r in v.Type == expect
                        ? result(v)
                        : expect.Convert(v).Match(
                                Some: x =&gt; result(x),
                                None: () =&gt; failure&lt;ValueToken&gt;($&quot;type mismatch {v.Type} found, expected {expect}&quot;)
                            )
                    select r;

            Parser&lt;ValueToken&gt; ternary =
                token(
                    from __ in attempt(reserved(&quot;if&quot;))
                    from eb in exprUnknownType
                    from ex in eb.Type == types.Bool
                        ? result(eb)
                        : failure&lt;ValueToken&gt;(&quot;ternary expressions must evaluate to a boolean value&quot;)
                    from th in reserved(&quot;then&quot;)
                    from te in exprUnknownType
                    from el in reserved(&quot;else&quot;)
                    from ee in exprUnknownType
                    select ((bool)ex.Value) ? te : ee
                );

            valueUntyped = choice(
                variable,
                choice(types.AllInOrder.Map(typ =&gt; attempt(typ.ValueParser(this).Map(val =&gt; new ValueToken(typ, typ.Ctor(None, val))))).ToArray())
            );

            // Expression term parser
            Parser&lt;ValueToken&gt; termUnknownType =
                choice(
                    parens(lazyp(() =&gt; exprUnknownType)),
                    ternary,
                    valueUntyped);

            // Expression parser
            exprUnknownType =
                buildExpressionParser(table, termUnknownType);

            // Variable declaration parser
            valueDef =
                from typ in either(
                    attempt(reserved(&quot;let&quot;)).Map(x =&gt; Option&lt;TypeDef&gt;.None),
                    typeName.Map(Option&lt;TypeDef&gt;.Some)
                )
                from arr in optional(symbol(&quot;[]&quot;))
                from _ in arr.IsSome &amp;&amp; typ.IsNone
                    ? failure&lt;Unit&gt;(&quot;when declaring an array you must specify the type, you can&#39;t use &#39;let&#39;&quot;)
                    : result&lt;Unit&gt;(unit)
                from id in identifier.label(&quot;identifier&quot;)
                from alias in optional(
                        from a_ in reserved(&quot;as&quot;)
                        from nm in identifier
                        select nm)
                from __ in symbol(&quot;:&quot;)
                from v in arr.IsSome
                    ? either(
                        attempt(valueInst(alias, TypeDef.Map(() =&gt; typ.IfNone(TypeDef.Unknown)))),
                        valueInst(alias, TypeDef.Array(() =&gt; typ.IfNone(TypeDef.Unknown))))
                    : typ.Map(t =&gt; expr(alias, t))
                         .IfNone(() =&gt; exprUnknownType)
                from nv in result(new NamedValueToken(id, v, alias))
                from state in getState&lt;ParserState&gt;()
                from res in state.LocalExists(id)
                    ? failure&lt;ParserState&gt;($&quot;A value with the name &#39;{id}&#39; already declared&quot;)
                    : result(state.AddLocal(id, v))
                from ___ in setState(res)
                select nv;

            // Value or variable parser
            valueInst = (alias, typ) =&gt; either(variableOfType(typ), typ.ValueParser(this).Map(value =&gt; new ValueToken(typ, typ.Ctor(alias, value))));

            // Expression term parser
            term =
                (alias, expected) =&gt;
                    choice(
                        parens(lazyp(() =&gt; expr(alias, expected))),
                        valueInst(alias,expected),
                        from val in exprUnknownType
                        from res in val.Type == expected
                            ? result(val)
                            : failure&lt;ValueToken&gt;($&quot;expression must evaluate to {expected}, it actually evaluates to {val.Type}&quot;)
                        select res
                    );

            // Expression parser
            expr =
                (alias, expected) =&gt;
                    buildExpressionParser(table, term(alias, expected));

            // Parses a named argument: name = value
            namedArgument =
                (settingName, spec) =&gt;
                    attempt(token(attr(spec.Name, expr(None, spec.Type()))));

            // Parses a single non-named argument
            argument =
                (settingName, spec) =&gt;
                    attempt(token(expr(None, spec.Type()).Map(x =&gt; new NamedValueToken(spec.Name, x, None))));

            // Parses many arguments, wrapped in ( )
            argumentMany =
                (settingName, spec) =&gt;
                    from a in commaSep1(choice(spec.Map(arg =&gt; namedArgument(settingName, arg))))
                    from r in a.Count == spec.Length
                        ? result(a)
                        : failure&lt;Lst&lt;NamedValueToken&gt;&gt;(&quot;Invalid arguments for &quot; + settingName)
                    select r;

            // Parses the arguments for a setting
            arguments =
                (settingName, spec) =&gt;
                    spec.Length == 0
                        ? failure&lt;Lst&lt;NamedValueToken&gt;&gt;(&quot;Invalid arguments spec, has zero arguments&quot;)
                        : spec.Length == 1
                            ? from a in argument(settingName, spec.Head())
                              select List.create(a)
                            : argumentMany(settingName, spec);

            // Declare the global type
            var globalType = new TypeDef(&quot;global&quot;, (_,x)=&gt;x, typeof(Lst&lt;NamedValueToken&gt;), nodeName, 0);

            // Global namespace
            parser = from ws in whiteSpace
                       from __ in setState(ParserState.Empty)
                       from ss in globalType.ValueParser(this)
                       select (Lst&lt;NamedValueToken&gt;)ss;
        </div></div></div><h2 >Fields</h2><div class="member-title"><a name="argument"></a>argument</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Func</span>&lt;<span class="keyword">string</span>, <span class="ident">FieldSpec</span>, <span class="ident">Parser</span>&lt;<span class="ident">NamedValueToken</span>&gt;&gt; <span class="ident">argument</span></div></div></div><div class="member-title"><a name="argumentMany"></a>argumentMany</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Func</span>&lt;<span class="keyword">string</span>, <span class="ident">FieldSpec</span>[], <span class="ident">Parser</span>&lt;<span class="ident">Lst</span>&lt;<span class="ident">NamedValueToken</span>&gt;&gt;&gt; <span class="ident">argumentMany</span></div></div></div><div class="member-title"><a name="arguments"></a>arguments</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Func</span>&lt;<span class="keyword">string</span>, <span class="ident">FieldSpec</span>[], <span class="ident">Parser</span>&lt;<span class="ident">Lst</span>&lt;<span class="ident">NamedValueToken</span>&gt;&gt;&gt; <span class="ident">arguments</span></div></div></div><div class="member-title"><a name="clusterType"></a>clusterType</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">TypeDef</span> <span class="ident">clusterType</span></div></div></div><div class="member-title"><a name="Definition"></a>Definition</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">GenLanguageDef</span> <span class="ident">Definition</span></div></div></div><div class="member-title"><a name="expr"></a>expr</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Func</span>&lt;<span class="ident">Option</span>&lt;<span class="keyword">string</span>&gt;, <span class="ident">TypeDef</span>, <span class="ident">Parser</span>&lt;<span class="ident">ValueToken</span>&gt;&gt; <span class="ident">expr</span></div></div></div><div class="member-title"><a name="exprUnknownType"></a>exprUnknownType</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Parser</span>&lt;<span class="ident">ValueToken</span>&gt; <span class="ident">exprUnknownType</span></div></div></div><div class="member-title"><a name="floating"></a>floating</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Parser</span>&lt;<span class="keyword">double</span>&gt; <span class="ident">floating</span></div></div></div><div class="member-title"><a name="identifier"></a>identifier</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Parser</span>&lt;<span class="keyword">string</span>&gt; <span class="ident">identifier</span></div></div></div><div class="member-title"><a name="integer"></a>integer</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Parser</span>&lt;<span class="keyword">int</span>&gt; <span class="ident">integer</span></div></div></div><div class="member-title"><a name="match"></a>match</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Parser</span>&lt;<span class="ident">ValueToken</span>&gt; <span class="ident">match</span></div></div></div><div class="member-title"><a name="namedArgument"></a>namedArgument</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Func</span>&lt;<span class="keyword">string</span>, <span class="ident">FieldSpec</span>, <span class="ident">Parser</span>&lt;<span class="ident">NamedValueToken</span>&gt;&gt; <span class="ident">namedArgument</span></div></div></div><div class="member-title"><a name="natural"></a>natural</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Parser</span>&lt;<span class="keyword">int</span>&gt; <span class="ident">natural</span></div></div></div><div class="member-title"><a name="nodeName"></a>nodeName</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">string</span> <span class="ident">nodeName</span></div></div></div><div class="member-title"><a name="parser"></a>parser</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="ident">Parser</span>&lt;<span class="ident">Lst</span>&lt;<span class="ident">NamedValueToken</span>&gt;&gt; <span class="ident">parser</span></div></div></div><div class="member-title"><a name="processId"></a>processId</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Parser</span>&lt;<span class="ident">ProcessId</span>&gt; <span class="ident">processId</span></div></div></div><div class="member-title"><a name="processName"></a>processName</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Parser</span>&lt;<span class="ident">ProcessName</span>&gt; <span class="ident">processName</span></div></div></div><div class="member-title"><a name="processType"></a>processType</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">TypeDef</span> <span class="ident">processType</span></div></div></div><div class="member-title"><a name="redirect"></a>redirect</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Parser</span>&lt;<span class="ident">ValueToken</span>&gt; <span class="ident">redirect</span></div></div></div><div class="member-title"><a name="reserved"></a>reserved</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Func</span>&lt;<span class="keyword">string</span>, <span class="ident">Parser</span>&lt;<span class="keyword">string</span>&gt;&gt; <span class="ident">reserved</span></div></div></div><div class="member-title"><a name="reservedOp"></a>reservedOp</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Func</span>&lt;<span class="keyword">string</span>, <span class="ident">Parser</span>&lt;<span class="ident">Unit</span>&gt;&gt; <span class="ident">reservedOp</span></div></div></div><div class="member-title"><a name="routerType"></a>routerType</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">TypeDef</span> <span class="ident">routerType</span></div></div></div><div class="member-title"><a name="strategyType"></a>strategyType</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">TypeDef</span> <span class="ident">strategyType</span></div></div></div><div class="member-title"><a name="stringLiteral"></a>stringLiteral</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Parser</span>&lt;<span class="keyword">string</span>&gt; <span class="ident">stringLiteral</span></div></div></div><div class="member-title"><a name="symbol"></a>symbol</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Func</span>&lt;<span class="keyword">string</span>, <span class="ident">Parser</span>&lt;<span class="keyword">string</span>&gt;&gt; <span class="ident">symbol</span></div></div></div><div class="member-title"><a name="term"></a>term</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Func</span>&lt;<span class="ident">Option</span>&lt;<span class="keyword">string</span>&gt;, <span class="ident">TypeDef</span>, <span class="ident">Parser</span>&lt;<span class="ident">ValueToken</span>&gt;&gt; <span class="ident">term</span></div></div></div><div class="member-title"><a name="TokenParser"></a>TokenParser</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">GenTokenParser</span> <span class="ident">TokenParser</span></div></div></div><div class="member-title"><a name="types"></a>types</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Types</span> <span class="ident">types</span></div></div></div><div class="member-title"><a name="valueDef"></a>valueDef</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Parser</span>&lt;<span class="ident">NamedValueToken</span>&gt; <span class="ident">valueDef</span></div></div></div><div class="member-title"><a name="valueUntyped"></a>valueUntyped</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Parser</span>&lt;<span class="ident">ValueToken</span>&gt; <span class="ident">valueUntyped</span></div></div></div><div class="member-title"><a name="whiteSpace"></a>whiteSpace</div><div class="section"><div class="left"></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="ident">Parser</span>&lt;<span class="ident">Unit</span>&gt; <span class="ident">whiteSpace</span></div></div></div><h2 >Methods</h2><div class="member-title"><a name="brackets&lt;T>"></a>brackets&lt;T&gt;(Parser&lt;T&gt;)<div class="source-link-cont"><a class="source-link" href="#" onclick="document.getElementById(&#39;code-brackets_T_Parser_T_p_&#39;).style.display=&#39;&#39;;">SOURCE</a></div></div><div class="section"><div class="left"><div class="section_title">PARAMETERS</div><div class="arg"><div class="arg-header"><div class="arg-name">p</div><div class="arg-type"><span class="ident">Parser</span>&lt;<span class="ident">T</span>&gt;</div></div></div></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="ident">Parser</span>&lt;<span class="ident">T</span>&gt; <span class="ident">brackets</span>&lt;<span class="ident">T</span>&gt;(<span class="ident">Parser</span>&lt;<span class="ident">T</span>&gt; p)</div><div class="section_title">RETURNS</div><div class="code"><div class="member-title"><span class="ident">Parser</span>&lt;<span class="ident">T</span>&gt;</div><div class="normal"></div></div></div><div style="display:none" id="code-brackets_T_Parser_T_p_"><div class="section_title">SOURCE</div><div class="code">
            TokenParser.Brackets(p)</div></div></div><div class="member-title"><a name="commaSep&lt;T>"></a>commaSep&lt;T&gt;(Parser&lt;T&gt;)<div class="source-link-cont"><a class="source-link" href="#" onclick="document.getElementById(&#39;code-commaSep_T_Parser_T_p_&#39;).style.display=&#39;&#39;;">SOURCE</a></div></div><div class="section"><div class="left"><div class="section_title">PARAMETERS</div><div class="arg"><div class="arg-header"><div class="arg-name">p</div><div class="arg-type"><span class="ident">Parser</span>&lt;<span class="ident">T</span>&gt;</div></div></div></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="ident">Parser</span>&lt;<span class="ident">Lst</span>&lt;<span class="ident">T</span>&gt;&gt; <span class="ident">commaSep</span>&lt;<span class="ident">T</span>&gt;(<span class="ident">Parser</span>&lt;<span class="ident">T</span>&gt; p)</div><div class="section_title">RETURNS</div><div class="code"><div class="member-title"><span class="ident">Parser</span>&lt;<span class="ident">Lst</span>&lt;<span class="ident">T</span>&gt;&gt;</div><div class="normal"></div></div></div><div style="display:none" id="code-commaSep_T_Parser_T_p_"><div class="section_title">SOURCE</div><div class="code">
            TokenParser.CommaSep(p)</div></div></div><div class="member-title"><a name="commaSep1&lt;T>"></a>commaSep1&lt;T&gt;(Parser&lt;T&gt;)<div class="source-link-cont"><a class="source-link" href="#" onclick="document.getElementById(&#39;code-commaSep1_T_Parser_T_p_&#39;).style.display=&#39;&#39;;">SOURCE</a></div></div><div class="section"><div class="left"><div class="section_title">PARAMETERS</div><div class="arg"><div class="arg-header"><div class="arg-name">p</div><div class="arg-type"><span class="ident">Parser</span>&lt;<span class="ident">T</span>&gt;</div></div></div></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="ident">Parser</span>&lt;<span class="ident">Lst</span>&lt;<span class="ident">T</span>&gt;&gt; <span class="ident">commaSep1</span>&lt;<span class="ident">T</span>&gt;(<span class="ident">Parser</span>&lt;<span class="ident">T</span>&gt; p)</div><div class="section_title">RETURNS</div><div class="code"><div class="member-title"><span class="ident">Parser</span>&lt;<span class="ident">Lst</span>&lt;<span class="ident">T</span>&gt;&gt;</div><div class="normal"></div></div></div><div style="display:none" id="code-commaSep1_T_Parser_T_p_"><div class="section_title">SOURCE</div><div class="code">
            TokenParser.CommaSep1(p)</div></div></div><div class="member-title"><a name="parens&lt;T>"></a>parens&lt;T&gt;(Parser&lt;T&gt;)<div class="source-link-cont"><a class="source-link" href="#" onclick="document.getElementById(&#39;code-parens_T_Parser_T_p_&#39;).style.display=&#39;&#39;;">SOURCE</a></div></div><div class="section"><div class="left"><div class="section_title">PARAMETERS</div><div class="arg"><div class="arg-header"><div class="arg-name">p</div><div class="arg-type"><span class="ident">Parser</span>&lt;<span class="ident">T</span>&gt;</div></div></div></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="ident">Parser</span>&lt;<span class="ident">T</span>&gt; <span class="ident">parens</span>&lt;<span class="ident">T</span>&gt;(<span class="ident">Parser</span>&lt;<span class="ident">T</span>&gt; p)</div><div class="section_title">RETURNS</div><div class="code"><div class="member-title"><span class="ident">Parser</span>&lt;<span class="ident">T</span>&gt;</div><div class="normal"></div></div></div><div style="display:none" id="code-parens_T_Parser_T_p_"><div class="section_title">SOURCE</div><div class="code">
            TokenParser.Parens(p)</div></div></div><div class="member-title"><a name="ParseConfigText"></a>ParseConfigText(string)<div class="source-link-cont"><a class="source-link" href="#" onclick="document.getElementById(&#39;code-ParseConfigText__string__text_&#39;).style.display=&#39;&#39;;">SOURCE</a></div></div><div class="section"><div class="left"><div class="section_title">PARAMETERS</div><div class="arg"><div class="arg-header"><div class="arg-name">text</div><div class="arg-type"><span class="keyword">string</span></div></div></div></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="ident">Map</span>&lt;<span class="ident">SystemName</span>, <span class="ident">ProcessSystemConfig</span>&gt; <span class="ident">ParseConfigText</span>(<span class="keyword">string</span> text)</div><div class="section_title">RETURNS</div><div class="code"><div class="member-title"><span class="ident">Map</span>&lt;<span class="ident">SystemName</span>, <span class="ident">ProcessSystemConfig</span>&gt;</div><div class="normal"></div></div></div><div style="display:none" id="code-ParseConfigText__string__text_"><div class="section_title">SOURCE</div><div class="code">
            // Parse the config text
            var res = parse(parser, text);
            if (res.IsFaulted || res.Reply.State.ToString().Length &gt; 0)
            {
                if (res.IsFaulted)
                {
                    throw new ProcessConfigException(res.ToString());
                }
                else
                {
                    var clipped = res.Reply.State.ToString();
                    clipped = clipped.Substring(0, Math.Min(40, clipped.Length));
                    throw new ProcessConfigException($&quot;Configuration parse error at {res.Reply.State.Pos}, near: {clipped}&quot;);
                }
            }

            // Extract the process settings
            var processSettings = List.fold(
                from nv in res.Reply.Result
                where nv.Value.Type == processType || nv.Value.Type == routerType
                let process = nv.Value.Cast&lt;ProcessToken&gt;()
                let pid = process.ProcessId
                where pid.IsSome
                let reg = process.RegisteredName
                let final = process.SetRegisteredName(new ValueToken(types.ProcessName, reg.IfNone(new ProcessName(nv.Name))))
                select Tuple(pid.IfNone(ProcessId.None), final),
                Map.empty&lt;ProcessId, ProcessToken&gt;(),
                (s, x) =&gt; Map.tryAdd(s, x.Item1, x.Item2, (_, p) =&gt; failwith&lt;Map&lt;ProcessId, ProcessToken&gt;&gt;(&quot;Process declared twice: &quot; + p.RegisteredName.IfNone(&quot;not defined&quot;))));


            // Extract the cluster settings
            var stratSettings = List.fold(
                from nv in res.Reply.Result
                where nv.Value.Type == strategyType
                let strategy = nv.Value.Cast&lt;State&lt;StrategyContext, Unit&gt;&gt;()
                select Tuple(nv.Name, strategy),
                Map.empty&lt;string, State&lt;StrategyContext, Unit&gt;&gt;(),
                (s, x) =&gt; Map.tryAdd(s, x.Item1, x.Item2, (_, __) =&gt; failwith&lt;Map&lt;string, State&lt;StrategyContext, Unit&gt;&gt;&gt;(&quot;Strategy declared twice: &quot; + x.Item1)));

            // Extract the strategy settings
            var clusterSettings = List.fold(
                from nv in res.Reply.Result
                where nv.Value.Type == clusterType
                let cluster = nv.Value.Cast&lt;ClusterToken&gt;()
                let env = cluster.Env
                let alias = cluster.Alias
                let key = alias || env
                let clusterNodeName = cluster.NodeName
                where clusterNodeName.Map(nn =&gt; nn == nodeName).IfNone(false)
                let final = cluster.SetEnvironment(new ValueToken(types.String, key.IfNone(nv.Name)))
                select Tuple(final.Env.IfNone(&quot;&quot;), final),
                Map.empty&lt;SystemName, ClusterToken&gt;(),
                (s, x) =&gt; Map.tryAdd(s, new SystemName(x.Item1), x.Item2, (_, c) =&gt; failwith&lt;Map&lt;SystemName, ClusterToken&gt;&gt;(&quot;Cluster declared twice: &quot; + c.Env.IfNone(&quot;&quot;))));

            var roleSettings = List.fold(
                res.Reply.Result,
                Map.empty&lt;string, ValueToken&gt;(),
                (s, x) =&gt; Map.addOrUpdate(s, x.Name, x.Value)
            );

            return String.IsNullOrEmpty(nodeName)
                ? Map.create(Tuple(default(SystemName), new ProcessSystemConfig(default(SystemName), &quot;root&quot;, roleSettings, processSettings, stratSettings, null, types)))
                : clusterSettings.Map(cluster =&gt; 
                      new ProcessSystemConfig(
                          cluster.Env.Map(e =&gt; new SystemName(e)).IfNone(default(SystemName)),
                          cluster.NodeName.IfNone(&quot;&quot;),
                          roleSettings, 
                          processSettings, 
                          stratSettings, 
                          cluster, 
                          types));
        </div></div></div><div class="member-title"><a name="token&lt;T>"></a>token&lt;T&gt;(Parser&lt;T&gt;)<div class="source-link-cont"><a class="source-link" href="#" onclick="document.getElementById(&#39;code-token_T_Parser_T_p_&#39;).style.display=&#39;&#39;;">SOURCE</a></div></div><div class="section"><div class="left"><div class="section_title">PARAMETERS</div><div class="arg"><div class="arg-header"><div class="arg-name">p</div><div class="arg-type"><span class="ident">Parser</span>&lt;<span class="ident">T</span>&gt;</div></div></div></div><div class="right"><div class="section_title">DECLARATION</div><div class="code"><span class="keyword">public</span> <span class="ident">Parser</span>&lt;<span class="ident">T</span>&gt; <span class="ident">token</span>&lt;<span class="ident">T</span>&gt;(<span class="ident">Parser</span>&lt;<span class="ident">T</span>&gt; p)</div><div class="section_title">RETURNS</div><div class="code"><div class="member-title"><span class="ident">Parser</span>&lt;<span class="ident">T</span>&gt;</div><div class="normal"></div></div></div><div style="display:none" id="code-token_T_Parser_T_p_"><div class="section_title">SOURCE</div><div class="code">
            TokenParser.Lexeme(p)</div></div></div></div></body></html>