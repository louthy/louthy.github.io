<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>LanguageExt.Core/Traits/Applicative</title>
<link href="style.css" rel="stylesheet" type="text/css"/></head>
<body class="js-enabled"><div id="package-header"><ul class="links" id="page-menu"><li><a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative" class="link">Source</a></li>
<li><a href="../index.html" class="link">Contents</a></li>
<li><a href="../../../index.html" class="link">Index</a></li></ul>
<p class="caption">LanguageExt.Core</p></div>
<div id="content"><div id="module-header"><p class="caption"><a href="../../index.html" class="link">LanguageExt.Core</a>
<span> ► </span>
<a href="../index.html" class="link">Traits</a>
<span> ► </span>
<a href="index.html" class="link">Applicative</a></p></div>
<p><strong>Applicative Functors</strong> are a <em>'stepping stone'</em> between functors and monads – they're probably less well-known but have some
interesting properties of their own when it comes to lifted expression evaluation.</p>
<p>Two of the major uses in language-ext is to enable <em>automatic parallel processing of effectful computations</em> and to
<em>automatically collect multiple errors when validating</em>. Those aren't the only usages – all the higher-kinded-types,
including the collection-types, have applicative traits.</p>
<p>The topic is too large to cover here, so take a look at <a href="https://paullouth.com/higher-kinds-in-c-with-language-ext-part-4-applicatives/">Paul Louth's Higher-Kinds series</a> for more information.</p>

<div id="table-of-contents"><p class="caption">Contents</p>
<ul><li><a href="#_0_Act_2" class="link"><div class="nowrap">Act
<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span></div></a></li>
<ul><li><a href="#Act_2_fun =
        _ => y => y_0" class="link"><div class="nowrap">fun =
        _ =&gt; y =&gt; y</div></a></li></ul>
<li><a href="#_0_ApplicativeLaw_1" class="link"><div class="nowrap">ApplicativeLaw
<span class='generics'>&lt;</span>F<span class='generics'>&gt;</span></div></a></li>
<ul><li><a href="#ApplicativeLaw_1_assert_0" class="link"><div class="nowrap">assert

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>bool<span class='generics'>&gt;</span>? equals = null<span class='parens'>)</span></div></a></li>
<li><a href="#ApplicativeLaw_1_validate_0" class="link"><div class="nowrap">validate

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>bool<span class='generics'>&gt;</span>? equals = null<span class='parens'>)</span></div></a></li>
<li><a href="#ApplicativeLaw_1_homomorphismLaw_0" class="link"><div class="nowrap">homomorphismLaw

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>bool<span class='generics'>&gt;</span> equals<span class='parens'>)</span></div></a></li>
<li><a href="#ApplicativeLaw_1_interchangeLaw_0" class="link"><div class="nowrap">interchangeLaw

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>bool<span class='generics'>&gt;</span> equals<span class='parens'>)</span></div></a></li>
<li><a href="#ApplicativeLaw_1_identityLaw_0" class="link"><div class="nowrap">identityLaw

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>bool<span class='generics'>&gt;</span> equals<span class='parens'>)</span></div></a></li>
<li><a href="#ApplicativeLaw_1_compositionLaw_0" class="link"><div class="nowrap">compositionLaw

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>bool<span class='generics'>&gt;</span> equals<span class='parens'>)</span></div></a></li>
<li><a href="#ApplicativeLaw_1_functorLaw_0" class="link"><div class="nowrap">functorLaw

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>bool<span class='generics'>&gt;</span> equals<span class='parens'>)</span></div></a></li></ul>
<li><a href="#_0_Applicative_1" class="link"><div class="nowrap">Applicative
<span class='generics'>&lt;</span>F<span class='generics'>&gt;</span></div></a></li>
<ul><li><a href="#Applicative_1_Pure_1" class="link"><div class="nowrap">Pure
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>A value<span class='parens'>)</span></div></a></li>
<li><a href="#Applicative_1_Apply_2" class="link"><div class="nowrap">Apply
<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<span class='parens'>(</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mf<span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='parens'>)</span></div></a></li>
<li><a href="#Applicative_1_Apply_2" class="link"><div class="nowrap">Apply
<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<span class='parens'>(</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mf<span class='comma'>, </span>Memo<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='parens'>)</span></div></a></li>
<li><a href="#Applicative_1_Apply_2" class="link"><div class="nowrap">Apply
<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<span class='parens'>(</span>Memo<span class='generics'>&lt;</span>F<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mf<span class='comma'>, </span>Memo<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='parens'>)</span></div></a></li>
<li><a href="#Applicative_1_Apply_2" class="link"><div class="nowrap">Apply
<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<span class='parens'>(</span>Memo<span class='generics'>&lt;</span>F<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mf<span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='parens'>)</span></div></a></li>
<li><a href="#Applicative_1_Action_2" class="link"><div class="nowrap">Action
<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<span class='parens'>(</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>B<span class='generics'>&gt;</span> mb<span class='parens'>)</span></div></a></li>
<li><a href="#Applicative_1_Action_2" class="link"><div class="nowrap">Action
<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<span class='parens'>(</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Memo<span class='generics'>&lt;</span>F<span class='comma'>, </span>B<span class='generics'>&gt;</span> mb<span class='parens'>)</span></div></a></li>
<li><a href="#Applicative_1_Action_2" class="link"><div class="nowrap">Action
<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<span class='parens'>(</span>Memo<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Memo<span class='generics'>&lt;</span>F<span class='comma'>, </span>B<span class='generics'>&gt;</span> mb<span class='parens'>)</span></div></a></li>
<li><a href="#Applicative_1_Action_2" class="link"><div class="nowrap">Action
<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<span class='parens'>(</span>Memo<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>B<span class='generics'>&gt;</span> mb<span class='parens'>)</span></div></a></li>
<li><a href="#Applicative_1_Actions_1" class="link"><div class="nowrap">Actions
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>params K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span>[] fas<span class='parens'>)</span></div></a></li>
<li><a href="#Applicative_1_Actions_1" class="link"><div class="nowrap">Actions
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Seq<span class='generics'>&lt;</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> fas<span class='parens'>)</span></div></a></li>
<li><a href="#Applicative_1_Actions_1" class="link"><div class="nowrap">Actions
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>IEnumerable<span class='generics'>&lt;</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> fas<span class='parens'>)</span></div></a></li>
<li><a href="#Applicative_1_Actions_1" class="link"><div class="nowrap">Actions
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>IAsyncEnumerable<span class='generics'>&lt;</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> fas<span class='parens'>)</span></div></a></li>
<li><a href="#Applicative_1_Between_3" class="link"><div class="nowrap">Between
<span class='generics'>&lt;</span>A<span class='comma'>, </span>OPEN<span class='comma'>, </span>CLOSE<span class='generics'>&gt;</span>
<span class='parens'>(</span>
        K<span class='generics'>&lt;</span>F<span class='comma'>, </span>OPEN<span class='generics'>&gt;</span> open<span class='comma'>, </span>
        K<span class='generics'>&lt;</span>F<span class='comma'>, </span>CLOSE<span class='generics'>&gt;</span> close<span class='comma'>, </span>
        K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span> p<span class='parens'>)</span></div></a></li>
<li><a href="#Applicative_1_Replicate_1" class="link"><div class="nowrap">Replicate
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>int count<span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span> fa<span class='parens'>)</span></div></a></li></ul></ul></div>
<div class="interface"><H1>Sub modules</H1>
<table><tbody><tr><td class="src clearfix"><span class="inst-left"><a href="Extensions/index.html" class="link">Extensions</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="Module/index.html" class="link">Module</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="Operators/index.html" class="link">Operators</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="Prelude/index.html" class="link">Prelude</a></span></td></tr></tbody></table>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="_0_Act_2" class="def">Act</a>
<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Act.cs#L5" class="link">Source</a>
<a href="#_0_Act_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>



<div class="subs methods"><p class="caption">Fields</p>
<div class="top"><p class="src"><span class="keyword">field</span>
Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Func<span class='generics'>&lt;</span>B<span class='comma'>, </span>B<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="Act_2_fun =
        _ => y => y_0" class="def">fun =
        _ =&gt; y =&gt; y</a>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Act.cs#L7" class="link">Source</a>
<a href="#Act_2_fun =
        _ => y => y_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>












</div></div>








</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="_0_ApplicativeLaw_1" class="def">ApplicativeLaw</a>
<span class='generics'>&lt;</span>F<span class='generics'>&gt;</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Laws.cs#L22" class="link">Source</a>
<a href="#_0_ApplicativeLaw_1" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> F : Applicative&lt;F&gt;</span></div></div></p>
<div class="doc"><div><p>Functions that test that Applicative-functor laws hold for the <code>F</code> applicative-functor provided.</p>
</div>
<div><p>NOTE: <code>Equals</code> must be implemented for the <code>K〈F, *〉</code> derived-type, so that the laws
can be proven to be true.  If your applicative-functor doesn't have <code>Equals</code> then you must provide
the optional <code>equals</code> parameter so that the equality of outcomes can be tested.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">F</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Applicative functor type</p>
</span></td></tr></tbody></table></div></div>
</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Unit
<a id="ApplicativeLaw_1_assert_0" class="def">assert</a>

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>bool<span class='generics'>&gt;</span>? equals = null<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Laws.cs#L33" class="link">Source</a>
<a href="#ApplicativeLaw_1_assert_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Assert that the applicative-functor laws hold</p>
</div>
<div><p>NOTE: <code>Equals</code> must be implemented for the <code>K〈F, *〉</code> derived-type, so that the laws
can be proven to be true.  If your applicative-functor doesn't have <code>Equals</code> then you must provide
the optional <code>equals</code> parameter so that the equality of outcomes can be tested.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Error<span class='comma'>, </span>Unit<span class='generics'>&gt;</span>
<a id="ApplicativeLaw_1_validate_0" class="def">validate</a>

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>bool<span class='generics'>&gt;</span>? equals = null<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Laws.cs#L45" class="link">Source</a>
<a href="#ApplicativeLaw_1_validate_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Validate that the applicative-functor laws hold</p>
</div>
<div><p>NOTE: <code>Equals</code> must be implemented for the <code>K〈F, *〉</code> derived-type, so that the laws
can be proven to be true.  If your applicative-functor doesn't have <code>Equals</code> then you must provide
the optional <code>equals</code> parameter so that the equality of outcomes can be tested.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Error<span class='comma'>, </span>Unit<span class='generics'>&gt;</span>
<a id="ApplicativeLaw_1_homomorphismLaw_0" class="def">homomorphismLaw</a>

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>bool<span class='generics'>&gt;</span> equals<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Laws.cs#L68" class="link">Source</a>
<a href="#ApplicativeLaw_1_homomorphismLaw_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Validate the homomorphism law</p>
</div>
<div><p>Homomorphism</p>

<p>NOTE: <code>Equals</code> must be implemented for the <code>K〈F, *〉</code> derived-type, so that the laws
can be proven to be true.  If your applicative-functor doesn't have <code>Equals</code> then you must provide
the optional <code>equals</code> parameter so that the equality of outcomes can be tested.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Error<span class='comma'>, </span>Unit<span class='generics'>&gt;</span>
<a id="ApplicativeLaw_1_interchangeLaw_0" class="def">interchangeLaw</a>

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>bool<span class='generics'>&gt;</span> equals<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Laws.cs#L95" class="link">Source</a>
<a href="#ApplicativeLaw_1_interchangeLaw_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Validate the interchange law</p>
</div>
<div><p>Interchange</p>

<p>NOTE: <code>Equals</code> must be implemented for the <code>K〈F, *〉</code> derived-type, so that the laws
can be proven to be true.  If your applicative-functor doesn't have <code>Equals</code> then you must provide
the optional <code>equals</code> parameter so that the equality of outcomes can be tested.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Error<span class='comma'>, </span>Unit<span class='generics'>&gt;</span>
<a id="ApplicativeLaw_1_identityLaw_0" class="def">identityLaw</a>

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>bool<span class='generics'>&gt;</span> equals<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Laws.cs#L124" class="link">Source</a>
<a href="#ApplicativeLaw_1_identityLaw_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Validate the identity law</p>
</div>
<div><p>Identity</p>

<p>NOTE: <code>Equals</code> must be implemented for the <code>K〈F, *〉</code> derived-type, so that the laws
can be proven to be true.  If your applicative-functor doesn't have <code>Equals</code> then you must provide
the optional <code>equals</code> parameter so that the equality of outcomes can be tested.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Error<span class='comma'>, </span>Unit<span class='generics'>&gt;</span>
<a id="ApplicativeLaw_1_compositionLaw_0" class="def">compositionLaw</a>

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>bool<span class='generics'>&gt;</span> equals<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Laws.cs#L145" class="link">Source</a>
<a href="#ApplicativeLaw_1_compositionLaw_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Validate the composition law</p>
</div>
<div><p>Composition</p>

<p>NOTE: <code>Equals</code> must be implemented for the <code>K〈F, *〉</code> derived-type, so that the laws
can be proven to be true.  If your functor doesn't have <code>Equals</code> then you must provide
the optional <code>equals</code> parameter so that the equality of outcomes can be tested.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Error<span class='comma'>, </span>Unit<span class='generics'>&gt;</span>
<a id="ApplicativeLaw_1_functorLaw_0" class="def">functorLaw</a>

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>int<span class='generics'>&gt;</span><span class='comma'>, </span>bool<span class='generics'>&gt;</span> equals<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Laws.cs#L174" class="link">Source</a>
<a href="#ApplicativeLaw_1_functorLaw_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Validate the functor law</p>
</div>
<div><p>Applicative-Functor</p>

<p>NOTE: <code>Equals</code> must be implemented for the <code>K〈F, *〉</code> derived-type, so that the laws
can be proven to be true.  If your functor doesn't have <code>Equals</code> then you must provide
the optional <code>equals</code> parameter so that the equality of outcomes can be tested.</p>
</div>

</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">interface</span>
<a id="_0_Applicative_1" class="def">Applicative</a>
<span class='generics'>&lt;</span>F<span class='generics'>&gt;</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Trait.cs#L16" class="link">Source</a>
<a href="#_0_Applicative_1" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> F : Applicative&lt;F&gt;</span></div></div></p>
<div class="doc"><div><p>Applicative functor</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">F</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Functor trait type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr></tbody></table></div></div>
</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Applicative_1_Pure_1" class="def">Pure</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>A value<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Trait.cs#L30" class="link">Source</a>
<a href="#Applicative_1_Pure_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Lift a pure value into the applicative structure</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">value</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Value to lift</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Constructed applicative structure</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
K<span class='generics'>&lt;</span>F<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<a id="Applicative_1_Apply_2" class="def">Apply</a>
<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<span class='parens'>(</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mf<span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Trait.cs#L45" class="link">Source</a>
<a href="#Applicative_1_Apply_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Apply the function to the argument.</p>
</div>
<div><p>This is like <code>delegate.Invoke</code> for lifted functions and lifted arguments.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Argument type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">B</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Return type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">mf</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Lifted function</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ma</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Lifted argument</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Applicative structure that represents the result of invoking the lifted function with
the lifted argument</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
K<span class='generics'>&lt;</span>F<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<a id="Applicative_1_Apply_2" class="def">Apply</a>
<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<span class='parens'>(</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mf<span class='comma'>, </span>Memo<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Trait.cs#L61" class="link">Source</a>
<a href="#Applicative_1_Apply_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Apply the function to the argument.
This is like <code>delegate.Invoke</code> for lifted functions and lifted arguments.</p>
</div>
<div><p>Uses memoisation for lazy and then cached evaluation of the argument.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Argument type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">B</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Return type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">mf</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Lifted function</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ma</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Lifted argument</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Applicative structure that represents the result of invoking the lifted function with
the lifted argument</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
K<span class='generics'>&lt;</span>F<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<a id="Applicative_1_Apply_2" class="def">Apply</a>
<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<span class='parens'>(</span>Memo<span class='generics'>&lt;</span>F<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mf<span class='comma'>, </span>Memo<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Trait.cs#L82" class="link">Source</a>
<a href="#Applicative_1_Apply_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Apply the function to the argument.
This is like <code>delegate.Invoke</code> for lifted functions and lifted arguments.</p>
</div>
<div><p>Uses memoisation for lazy and then cached evaluation of the argument.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Argument type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">B</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Return type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">mf</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Lifted function</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ma</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Lifted argument</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Applicative structure that represents the result of invoking the lifted function with
the lifted argument</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
K<span class='generics'>&lt;</span>F<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<a id="Applicative_1_Apply_2" class="def">Apply</a>
<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<span class='parens'>(</span>Memo<span class='generics'>&lt;</span>F<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mf<span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Trait.cs#L99" class="link">Source</a>
<a href="#Applicative_1_Apply_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Apply the function to the argument.
This is like <code>delegate.Invoke</code> for lifted functions and lifted arguments.</p>
</div>
<div><p>Uses memoisation for lazy and then cached evaluation of the argument.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Argument type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">B</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Return type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">mf</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Lifted function</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ma</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Lifted argument</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Applicative structure that represents the result of invoking the lifted function with
the lifted argument</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
K<span class='generics'>&lt;</span>F<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<a id="Applicative_1_Action_2" class="def">Action</a>
<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<span class='parens'>(</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>B<span class='generics'>&gt;</span> mb<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Trait.cs#L111" class="link">Source</a>
<a href="#Applicative_1_Action_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Applicative action.  Computes the first applicative action and then computes the second.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>First applicative structure bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">B</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Second applicative structure bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ma</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>First applicative structure</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">mb</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Second applicative structure</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The result of the second applicative action (if there wasn't a failure beforehand)</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
K<span class='generics'>&lt;</span>F<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<a id="Applicative_1_Action_2" class="def">Action</a>
<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<span class='parens'>(</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Memo<span class='generics'>&lt;</span>F<span class='comma'>, </span>B<span class='generics'>&gt;</span> mb<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Trait.cs#L123" class="link">Source</a>
<a href="#Applicative_1_Action_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Applicative action.  Computes the first applicative action and then computes the second.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>First applicative structure bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">B</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Second applicative structure bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ma</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>First applicative structure</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">mb</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Second applicative structure</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The result of the second applicative action (if there wasn't a failure beforehand)</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
K<span class='generics'>&lt;</span>F<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<a id="Applicative_1_Action_2" class="def">Action</a>
<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<span class='parens'>(</span>Memo<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Memo<span class='generics'>&lt;</span>F<span class='comma'>, </span>B<span class='generics'>&gt;</span> mb<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Trait.cs#L135" class="link">Source</a>
<a href="#Applicative_1_Action_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Applicative action.  Computes the first applicative action and then computes the second.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>First applicative structure bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">B</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Second applicative structure bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ma</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>First applicative structure</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">mb</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Second applicative structure</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The result of the second applicative action (if there wasn't a failure beforehand)</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
K<span class='generics'>&lt;</span>F<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<a id="Applicative_1_Action_2" class="def">Action</a>
<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<span class='parens'>(</span>Memo<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>B<span class='generics'>&gt;</span> mb<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Trait.cs#L147" class="link">Source</a>
<a href="#Applicative_1_Action_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Applicative action.  Computes the first applicative action and then computes the second.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>First applicative structure bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">B</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Second applicative structure bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ma</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>First applicative structure</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">mb</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Second applicative structure</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The result of the second applicative action (if there wasn't a failure beforehand)</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Applicative_1_Actions_1" class="def">Actions</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>params K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span>[] fas<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Trait.cs#L175" class="link">Source</a>
<a href="#Applicative_1_Actions_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Chains a sequence of applicative actions</p>
</div>
<div><p>Because this is an abstract chaining of actions, it can't actually run anything, and so if your
actions are expected to have side effects (IO effects, for example), then you won't see them until
the resulting <code>K〈F, A〉</code> is 'run'.</p>
<p>This matters for infinite streams, where the result of <code>Actions</code> isn't realised at all, and so to
avoid nothing happening (no side effects), you should override this function and unpack the IO
type within, then run that enumerable of IOs.</p>
<p>A good example is with the <code>Eff</code> type.  It's a <code>ReaderT〈IO, A〉</code> internally:</p>
<pre class='language-csharp'><code>static K〈Eff〈RT〉, A〉 Actions〈A〉(IEnumerable〈K〈Eff〈RT〉, A〉〉 fas) =〉
    new Eff〈RT, A〉(
        new ReaderT〈RT, IO, A〉(
            rt =〉fas.Select(fa =〉fa.RunIO(rt)).Actions()));
</code></pre>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">fas</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Actions to chain</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"></span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Applicative_1_Actions_1" class="def">Actions</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Seq<span class='generics'>&lt;</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> fas<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Trait.cs#L203" class="link">Source</a>
<a href="#Applicative_1_Actions_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Chains a sequence of applicative actions</p>
</div>
<div><p>Because this is an abstract chaining of actions, it can't actually run anything, and so if your
actions are expected to have side effects (IO effects, for example), then you won't see them until
the resulting <code>K〈F, A〉</code> is 'run'.</p>
<p>This matters for infinite streams, where the result of <code>Actions</code> isn't realised at all, and so to
avoid nothing happening (no side effects), you should override this function and unpack the IO
type within, then run that enumerable of IOs.</p>
<p>A good example is with the <code>Eff</code> type.  It's a <code>ReaderT〈IO, A〉</code> internally:</p>
<pre class='language-csharp'><code>static K〈Eff〈RT〉, A〉 Actions〈A〉(IEnumerable〈K〈Eff〈RT〉, A〉〉 fas) =〉
    new Eff〈RT, A〉(
        new ReaderT〈RT, IO, A〉(
            rt =〉fas.Select(fa =〉fa.RunIO(rt)).Actions()));
</code></pre>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">fas</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Actions to chain</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"></span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Applicative_1_Actions_1" class="def">Actions</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>IEnumerable<span class='generics'>&lt;</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> fas<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Trait.cs#L231" class="link">Source</a>
<a href="#Applicative_1_Actions_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Chains a sequence of applicative actions</p>
</div>
<div><p>Because this is an abstract chaining of actions, it can't actually run anything, and so if your
actions are expected to have side effects (IO effects, for example), then you won't see them until
the resulting <code>K〈F, A〉</code> is 'run'.</p>
<p>This matters for infinite streams, where the result of <code>Actions</code> isn't realised at all, and so to
avoid nothing happening (no side effects), you should override this function and unpack the IO
type within, then run that enumerable of IOs.</p>
<p>A good example is with the <code>Eff</code> type.  It's a <code>ReaderT〈IO, A〉</code> internally:</p>
<pre class='language-csharp'><code>static K〈Eff〈RT〉, A〉 Actions〈A〉(IEnumerable〈K〈Eff〈RT〉, A〉〉 fas) =〉
    new Eff〈RT, A〉(
        new ReaderT〈RT, IO, A〉(
            rt =〉fas.Select(fa =〉fa.RunIO(rt)).Actions()));
</code></pre>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">fas</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Actions to chain</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"></span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Applicative_1_Actions_1" class="def">Actions</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>IAsyncEnumerable<span class='generics'>&lt;</span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> fas<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Trait.cs#L270" class="link">Source</a>
<a href="#Applicative_1_Actions_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Chains a sequence of applicative actions</p>
</div>
<div><p>Because this is an abstract chaining of actions, it can't actually run anything, and so if your
actions are expected to have side effects (IO effects, for example), then you won't see them until
the resulting <code>K〈F, A〉</code> is 'run'.</p>
<p>This matters for infinite streams, where the result of <code>Actions</code> isn't realised at all, and so to
avoid nothing happening (no side effects), you should override this function and unpack the IO
type within, then run that enumerable of IOs.</p>
<p>A good example is with the <code>Eff</code> type.  It's a <code>ReaderT〈IO, A〉</code> internally:</p>
<pre class='language-csharp'><code>static K〈Eff〈RT〉, A〉 Actions〈A〉(IEnumerable〈K〈Eff〈RT〉, A〉〉 fas) =〉
    new Eff〈RT, A〉(
        new ReaderT〈RT, IO, A〉(
            rt =〉 fas.Select(fa =〉 fa.RunIO(rt)).Actions()));
</code></pre>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">fas</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Actions to chain</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"></span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Applicative_1_Between_3" class="def">Between</a>
<span class='generics'>&lt;</span>A<span class='comma'>, </span>OPEN<span class='comma'>, </span>CLOSE<span class='generics'>&gt;</span>
<span class='parens'>(</span>
        K<span class='generics'>&lt;</span>F<span class='comma'>, </span>OPEN<span class='generics'>&gt;</span> open<span class='comma'>, </span>
        K<span class='generics'>&lt;</span>F<span class='comma'>, </span>CLOSE<span class='generics'>&gt;</span> close<span class='comma'>, </span>
        K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span> p<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Trait.cs#L289" class="link">Source</a>
<a href="#Applicative_1_Between_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p><code>between(open, close, p) parses </code>open<code>, followed by </code>p<code>and</code>close`.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Return value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">OPEN</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>OPEN value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">CLOSE</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>CLOSE value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">open</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Open computation</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">close</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Close computation</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">p</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Between computation</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned by <code>p</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
K<span class='generics'>&lt;</span>F<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="Applicative_1_Replicate_1" class="def">Replicate</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>int count<span class='comma'>, </span>K<span class='generics'>&lt;</span>F<span class='comma'>, </span>A<span class='generics'>&gt;</span> fa<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Traits/Applicative/Applicative.Trait.cs#L303" class="link">Source</a>
<a href="#Applicative_1_Replicate_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Construct a sequence of <code>count</code> repetitions of <code>fa</code></p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">count</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Number of repetitions</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">fa</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Applicative computation to run</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Applicative structure of <code>count</code> items</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div></div></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-core.min.js" integrity="sha512-9khQRAUBYEJDCDVP2yw3LRUQvjJ0Pjx0EShmaQjcHa6AXiOv6qHQu9lCAIR8O+/D8FtaCoJ2c0Tf9Xo7hYH01Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-fTl/qcO1VgvKtOMApX2PdZzkziyr2stM65GYPLGuYMnuMm1z2JLJG6XVU7C/mR+E7xBUqCivykuhlzfqxXBXbg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script></body></html>