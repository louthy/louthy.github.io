<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>LanguageExt.Core\Transformer\Sequence0</title>
<link href="style.css" rel="stylesheet" type="text/css"/></head>
<body class="js-enabled"><div id="package-header"><ul class="links" id="page-menu"><li><a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0" class="link">Source</a></li>
<li><a href="../index.html" class="link">Contents</a></li>
<li><a href="../../../index.html" class="link">Index</a></li></ul>
<p class="caption">LanguageExt.Core</p></div>
<div id="content"><div id="module-header"><p class="caption"><a href="../../index.html" class="link">LanguageExt.Core</a>
<span> ► </span>
<a href="../index.html" class="link">Transformer</a>
<span> ► </span>
<a href="index.html" class="link">Sequence0</a></p></div>
<div id="table-of-contents">
<p class="caption">Contents</p>
<ul><li><a href="#LanguageExt_0_AffPureT_0" class="link"><div class="nowrap">AffPureT
</div></a></li>
<ul><li><a href="#AffPureT_0_SequenceParallel_1" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceParallel_1" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceSerial_1" class="link"><div class="nowrap">SequenceSerial
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceParallel_1" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceParallel_1" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceSerial_1" class="link"><div class="nowrap">SequenceSerial
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceParallel_1" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceParallel_1" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceSerial_1" class="link"><div class="nowrap">SequenceSerial
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryAsync<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceParallel_1" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Que<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceParallel_1" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Que<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceSerial_1" class="link"><div class="nowrap">SequenceSerial
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Que<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceParallel_1" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceParallel_1" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceSerial_1" class="link"><div class="nowrap">SequenceSerial
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceParallel_1" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceParallel_1" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceSerial_1" class="link"><div class="nowrap">SequenceSerial
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceParallel_1" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceParallel_1" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceSerial_1" class="link"><div class="nowrap">SequenceSerial
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceParallel_1" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceParallel_1" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_SequenceSerial_1" class="link"><div class="nowrap">SequenceSerial
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Task<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionAsync<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOptionAsync<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_AffT_0" class="link"><div class="nowrap">AffT
</div></a></li>
<ul><li><a href="#AffT_0_SequenceParallel_2" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceParallel_2" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceSerial_2" class="link"><div class="nowrap">SequenceSerial
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceParallel_2" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceParallel_2" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceSerial_2" class="link"><div class="nowrap">SequenceSerial
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceParallel_2" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceParallel_2" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceSerial_2" class="link"><div class="nowrap">SequenceSerial
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryAsync<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceParallel_2" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceParallel_2" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceSerial_2" class="link"><div class="nowrap">SequenceSerial
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceParallel_2" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceParallel_2" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceSerial_2" class="link"><div class="nowrap">SequenceSerial
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceParallel_2" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceParallel_2" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceSerial_2" class="link"><div class="nowrap">SequenceSerial
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceParallel_2" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Que<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceParallel_2" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Que<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceSerial_2" class="link"><div class="nowrap">SequenceSerial
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Que<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceSerial_2" class="link"><div class="nowrap">SequenceSerial
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceParallel_2" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_SequenceParallel_2" class="link"><div class="nowrap">SequenceParallel
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_4" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Task<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionAsync<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOptionAsync<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Aff<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_ArrT_0" class="link"><div class="nowrap">ArrT
</div></a></li>
<ul><li><a href="#ArrT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ArrT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ArrT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ArrT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ArrT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ArrT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ArrT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ArrT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ArrT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ArrT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ArrT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ArrT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ArrT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ArrT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ArrT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ArrT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ArrT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_EffPureT_0" class="link"><div class="nowrap">EffPureT
</div></a></li>
<ul><li><a href="#EffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span></div></a></li>
<li><a href="#EffPureT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#EffPureT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#EffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#EffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#EffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#EffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#EffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#EffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#EffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span></div></a></li>
<li><a href="#EffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span></div></a></li>
<li><a href="#EffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span></div></a></li>
<li><a href="#EffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Que<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span></div></a></li>
<li><a href="#EffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span></div></a></li>
<li><a href="#EffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#EffPureT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#EffPureT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#EffPureT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_AffT_0" class="link"><div class="nowrap">AffT
</div></a></li>
<ul><li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Que<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_4" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li>
<li><a href="#AffT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_EitherAsyncT_0" class="link"><div class="nowrap">EitherAsyncT
</div></a></li>
<ul><li><a href="#EitherAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherAsyncT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryAsync<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Task<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOptionAsync<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionAsync<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Aff<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_EitherT_0" class="link"><div class="nowrap">EitherT
</div></a></li>
<ul><li><a href="#EitherT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Either<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_EitherUnsafeT_0" class="link"><div class="nowrap">EitherUnsafeT
</div></a></li>
<ul><li><a href="#EitherUnsafeT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherUnsafeT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherUnsafeT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherUnsafeT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherUnsafeT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherUnsafeT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherUnsafeT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherUnsafeT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherUnsafeT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherUnsafeT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherUnsafeT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherUnsafeT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherUnsafeT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherUnsafeT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherUnsafeT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#EitherUnsafeT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_FinT_0" class="link"><div class="nowrap">FinT
</div></a></li>
<ul><li><a href="#FinT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#FinT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#FinT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#FinT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#FinT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#FinT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#FinT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#FinT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#FinT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#FinT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#FinT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#FinT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#FinT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#FinT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#FinT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#FinT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#FinT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_HashSetT_0" class="link"><div class="nowrap">HashSetT
</div></a></li>
<ul><li><a href="#HashSetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#HashSetT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#HashSetT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#HashSetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#HashSetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#HashSetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#HashSetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#HashSetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#HashSetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#HashSetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#HashSetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#HashSetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#HashSetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#HashSetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#HashSetT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#HashSetT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#HashSetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_IEnumerableT_0" class="link"><div class="nowrap">IEnumerableT
</div></a></li>
<ul><li><a href="#IEnumerableT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#IEnumerableT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#IEnumerableT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#IEnumerableT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#IEnumerableT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#IEnumerableT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#IEnumerableT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#IEnumerableT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#IEnumerableT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#IEnumerableT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Que<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#IEnumerableT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#IEnumerableT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#IEnumerableT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#IEnumerableT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#IEnumerableT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#IEnumerableT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#IEnumerableT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#IEnumerableT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_LstT_0" class="link"><div class="nowrap">LstT
</div></a></li>
<ul><li><a href="#LstT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#LstT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#LstT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#LstT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#LstT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#LstT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#LstT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#LstT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#LstT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#LstT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#LstT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#LstT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#LstT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#LstT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#LstT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#LstT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#LstT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_OptionAsyncT_0" class="link"><div class="nowrap">OptionAsyncT
</div></a></li>
<ul><li><a href="#OptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionAsync<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionAsyncT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>
            this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryAsync<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Task<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOptionAsync<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Aff<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_OptionT_0" class="link"><div class="nowrap">OptionT
</div></a></li>
<ul><li><a href="#OptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_OptionUnsafeT_0" class="link"><div class="nowrap">OptionUnsafeT
</div></a></li>
<ul><li><a href="#OptionUnsafeT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionUnsafeT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionUnsafeT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionUnsafeT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionUnsafeT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionUnsafeT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionUnsafeT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionUnsafeT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionUnsafeT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionUnsafeT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionUnsafeT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionUnsafeT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionUnsafeT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionUnsafeT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionUnsafeT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionUnsafeT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#OptionUnsafeT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_QueT_0" class="link"><div class="nowrap">QueT
</div></a></li>
<ul><li><a href="#QueT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#QueT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#QueT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#QueT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#QueT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#QueT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#QueT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#QueT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#QueT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#QueT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#QueT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#QueT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#QueT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#QueT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#QueT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_ReaderT_0" class="link"><div class="nowrap">ReaderT
</div></a></li>
<ul><li><a href="#ReaderT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ReaderT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ReaderT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ReaderT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span>[] ta<span class='parens'>)</span></div></a></li>
<li><a href="#ReaderT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ReaderT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ReaderT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ReaderT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_RwsT_0" class="link"><div class="nowrap">RwsT
</div></a></li>
<ul><li><a href="#RwsT_0_Sequence_5" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#RwsT_0_Sequence_5" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#RwsT_0_Sequence_5" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#RwsT_0_Sequence_5" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>[] ta<span class='parens'>)</span></div></a></li>
<li><a href="#RwsT_0_Sequence_5" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#RwsT_0_Sequence_5" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#RwsT_0_Sequence_5" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#RwsT_0_Sequence_5" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_SeqT_0" class="link"><div class="nowrap">SeqT
</div></a></li>
<ul><li><a href="#SeqT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SeqT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SeqT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SeqT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SeqT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SeqT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SeqT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SeqT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SeqT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SeqT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SeqT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SeqT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SeqT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SeqT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SeqT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SeqT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SeqT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_SetT_0" class="link"><div class="nowrap">SetT
</div></a></li>
<ul><li><a href="#SetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SetT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SetT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SetT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SetT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#SetT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_StateT_0" class="link"><div class="nowrap">StateT
</div></a></li>
<ul><li><a href="#StateT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>State<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#StateT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>State<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#StateT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>State<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#StateT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this State<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>[] ta<span class='parens'>)</span></div></a></li>
<li><a href="#StateT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>State<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#StateT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>State<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#StateT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>State<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#StateT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>State<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_StckT_0" class="link"><div class="nowrap">StckT
</div></a></li>
<ul><li><a href="#StckT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#StckT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#StckT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#StckT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#StckT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#StckT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#StckT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#StckT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#StckT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#StckT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#StckT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#StckT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#StckT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#StckT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#StckT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_TaskT_0" class="link"><div class="nowrap">TaskT
</div></a></li>
<ul><li><a href="#TaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TaskT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TaskT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Task<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TaskT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TaskT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryAsync<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionAsync<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOptionAsync<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TaskT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Aff<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_TryAsyncT_0" class="link"><div class="nowrap">TryAsyncT
</div></a></li>
<ul><li><a href="#TryAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryAsync<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryAsyncT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Task<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionAsync<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOptionAsync<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Aff<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_TryOptionAsyncT_0" class="link"><div class="nowrap">TryOptionAsyncT
</div></a></li>
<ul><li><a href="#TryOptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryAsync<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionAsyncT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Task<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionAsync<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOptionAsync<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionAsyncT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Aff<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionAsyncT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_TryOptionT_0" class="link"><div class="nowrap">TryOptionT
</div></a></li>
<ul><li><a href="#TryOptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryOptionT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_TryT_0" class="link"><div class="nowrap">TryT
</div></a></li>
<ul><li><a href="#TryT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#TryT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_ValidationT_0" class="link"><div class="nowrap">ValidationT
</div></a></li>
<ul><li><a href="#ValidationT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_ValidationT_0" class="link"><div class="nowrap">ValidationT
</div></a></li>
<ul><li><a href="#ValidationT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValidationT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_ValueTaskT_0" class="link"><div class="nowrap">ValueTaskT
</div></a></li>
<ul><li><a href="#ValueTaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValueTaskT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValueTaskT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValueTaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValueTaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this ValueTask<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValueTaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValueTaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValueTaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValueTaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValueTaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValueTaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValueTaskT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValueTaskT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValueTaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryAsync<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValueTaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionAsync<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValueTaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOptionAsync<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValueTaskT_0_Sequence_2" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValueTaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Aff<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#ValueTaskT_0_Sequence_1" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_WriterT_0" class="link"><div class="nowrap">WriterT
</div></a></li>
<ul><li><a href="#WriterT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#WriterT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#WriterT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#WriterT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span>[] ta<span class='parens'>)</span></div></a></li>
<li><a href="#WriterT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#WriterT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#WriterT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li>
<li><a href="#WriterT_0_Sequence_3" class="link"><div class="nowrap">Sequence
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span></div></a></li></ul></ul></div>
<div class="interface">

<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_AffPureT_0" class="def">AffPureT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L11" class="link">Source</a>
<a href="#LanguageExt_0_AffPureT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceParallel_1" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L20" class="link">Source</a>
<a href="#AffPureT_0_SequenceParallel_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceParallel_1" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L31" class="link">Source</a>
<a href="#AffPureT_0_SequenceParallel_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceSerial_1" class="def">SequenceSerial</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L42" class="link">Source</a>
<a href="#AffPureT_0_SequenceSerial_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L53" class="link">Source</a>
<a href="#AffPureT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L64" class="link">Source</a>
<a href="#AffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L75" class="link">Source</a>
<a href="#AffPureT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L86" class="link">Source</a>
<a href="#AffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceParallel_1" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L97" class="link">Source</a>
<a href="#AffPureT_0_SequenceParallel_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceParallel_1" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L108" class="link">Source</a>
<a href="#AffPureT_0_SequenceParallel_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceSerial_1" class="def">SequenceSerial</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L119" class="link">Source</a>
<a href="#AffPureT_0_SequenceSerial_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceParallel_1" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L130" class="link">Source</a>
<a href="#AffPureT_0_SequenceParallel_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceParallel_1" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L141" class="link">Source</a>
<a href="#AffPureT_0_SequenceParallel_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceSerial_1" class="def">SequenceSerial</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L152" class="link">Source</a>
<a href="#AffPureT_0_SequenceSerial_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryAsync<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L163" class="link">Source</a>
<a href="#AffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L174" class="link">Source</a>
<a href="#AffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L185" class="link">Source</a>
<a href="#AffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceParallel_1" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Que<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L196" class="link">Source</a>
<a href="#AffPureT_0_SequenceParallel_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceParallel_1" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Que<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L207" class="link">Source</a>
<a href="#AffPureT_0_SequenceParallel_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceSerial_1" class="def">SequenceSerial</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Que<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L218" class="link">Source</a>
<a href="#AffPureT_0_SequenceSerial_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceParallel_1" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L229" class="link">Source</a>
<a href="#AffPureT_0_SequenceParallel_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceParallel_1" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L240" class="link">Source</a>
<a href="#AffPureT_0_SequenceParallel_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceSerial_1" class="def">SequenceSerial</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L251" class="link">Source</a>
<a href="#AffPureT_0_SequenceSerial_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceParallel_1" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L262" class="link">Source</a>
<a href="#AffPureT_0_SequenceParallel_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceParallel_1" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L273" class="link">Source</a>
<a href="#AffPureT_0_SequenceParallel_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceSerial_1" class="def">SequenceSerial</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L284" class="link">Source</a>
<a href="#AffPureT_0_SequenceSerial_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceParallel_1" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L295" class="link">Source</a>
<a href="#AffPureT_0_SequenceParallel_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceParallel_1" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L306" class="link">Source</a>
<a href="#AffPureT_0_SequenceParallel_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceSerial_1" class="def">SequenceSerial</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L317" class="link">Source</a>
<a href="#AffPureT_0_SequenceSerial_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceParallel_1" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L328" class="link">Source</a>
<a href="#AffPureT_0_SequenceParallel_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceParallel_1" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L339" class="link">Source</a>
<a href="#AffPureT_0_SequenceParallel_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_SequenceSerial_1" class="def">SequenceSerial</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L350" class="link">Source</a>
<a href="#AffPureT_0_SequenceSerial_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L361" class="link">Source</a>
<a href="#AffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L372" class="link">Source</a>
<a href="#AffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L383" class="link">Source</a>
<a href="#AffPureT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L394" class="link">Source</a>
<a href="#AffPureT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Task<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L406" class="link">Source</a>
<a href="#AffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionAsync<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L417" class="link">Source</a>
<a href="#AffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOptionAsync<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L428" class="link">Source</a>
<a href="#AffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L439" class="link">Source</a>
<a href="#AffPureT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffPureT.cs#L450" class="link">Source</a>
<a href="#AffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_AffT_0" class="def">AffT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L12" class="link">Source</a>
<a href="#LanguageExt_0_AffT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceParallel_2" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L21" class="link">Source</a>
<a href="#AffT_0_SequenceParallel_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceParallel_2" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L33" class="link">Source</a>
<a href="#AffT_0_SequenceParallel_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceSerial_2" class="def">SequenceSerial</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L45" class="link">Source</a>
<a href="#AffT_0_SequenceSerial_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L57" class="link">Source</a>
<a href="#AffT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L69" class="link">Source</a>
<a href="#AffT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L81" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceParallel_2" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L93" class="link">Source</a>
<a href="#AffT_0_SequenceParallel_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceParallel_2" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L105" class="link">Source</a>
<a href="#AffT_0_SequenceParallel_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceSerial_2" class="def">SequenceSerial</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L117" class="link">Source</a>
<a href="#AffT_0_SequenceSerial_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceParallel_2" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L129" class="link">Source</a>
<a href="#AffT_0_SequenceParallel_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceParallel_2" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L141" class="link">Source</a>
<a href="#AffT_0_SequenceParallel_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceSerial_2" class="def">SequenceSerial</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L153" class="link">Source</a>
<a href="#AffT_0_SequenceSerial_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryAsync<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L165" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L177" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L189" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L201" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceParallel_2" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L213" class="link">Source</a>
<a href="#AffT_0_SequenceParallel_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceParallel_2" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L225" class="link">Source</a>
<a href="#AffT_0_SequenceParallel_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceSerial_2" class="def">SequenceSerial</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L237" class="link">Source</a>
<a href="#AffT_0_SequenceSerial_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceParallel_2" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L249" class="link">Source</a>
<a href="#AffT_0_SequenceParallel_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceParallel_2" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L261" class="link">Source</a>
<a href="#AffT_0_SequenceParallel_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceSerial_2" class="def">SequenceSerial</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L273" class="link">Source</a>
<a href="#AffT_0_SequenceSerial_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceParallel_2" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L285" class="link">Source</a>
<a href="#AffT_0_SequenceParallel_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceParallel_2" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L297" class="link">Source</a>
<a href="#AffT_0_SequenceParallel_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceSerial_2" class="def">SequenceSerial</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L309" class="link">Source</a>
<a href="#AffT_0_SequenceSerial_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceParallel_2" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Que<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L321" class="link">Source</a>
<a href="#AffT_0_SequenceParallel_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceParallel_2" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Que<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L333" class="link">Source</a>
<a href="#AffT_0_SequenceParallel_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceSerial_2" class="def">SequenceSerial</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Que<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L345" class="link">Source</a>
<a href="#AffT_0_SequenceSerial_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceSerial_2" class="def">SequenceSerial</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L357" class="link">Source</a>
<a href="#AffT_0_SequenceSerial_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceParallel_2" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L369" class="link">Source</a>
<a href="#AffT_0_SequenceParallel_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_SequenceParallel_2" class="def">SequenceParallel</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='comma'>, </span>int windowSize<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L381" class="link">Source</a>
<a href="#AffT_0_SequenceParallel_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L393" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L405" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L417" class="link">Source</a>
<a href="#AffT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_4" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L429" class="link">Source</a>
<a href="#AffT_0_Sequence_4" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt; 
            </span></div>
<div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Task<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L442" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionAsync<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L454" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOptionAsync<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L466" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L478" class="link">Source</a>
<a href="#AffT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Aff<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L490" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L502" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/AffT.cs#L514" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_ArrT_0" class="def">ArrT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ArrT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_ArrT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Arr<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ArrT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ArrT.cs#L19" class="link">Source</a>
<a href="#ArrT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Arr<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ArrT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ArrT.cs#L30" class="link">Source</a>
<a href="#ArrT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Arr<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ArrT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ArrT.cs#L41" class="link">Source</a>
<a href="#ArrT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Arr<span class='generics'>&lt;</span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ArrT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ArrT.cs#L52" class="link">Source</a>
<a href="#ArrT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Arr<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ArrT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ArrT.cs#L63" class="link">Source</a>
<a href="#ArrT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Arr<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ArrT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ArrT.cs#L74" class="link">Source</a>
<a href="#ArrT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Arr<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ArrT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ArrT.cs#L85" class="link">Source</a>
<a href="#ArrT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Arr<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ArrT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ArrT.cs#L96" class="link">Source</a>
<a href="#ArrT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Arr<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ArrT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ArrT.cs#L107" class="link">Source</a>
<a href="#ArrT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Arr<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ArrT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ArrT.cs#L118" class="link">Source</a>
<a href="#ArrT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Arr<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ArrT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ArrT.cs#L129" class="link">Source</a>
<a href="#ArrT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Arr<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ArrT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ArrT.cs#L140" class="link">Source</a>
<a href="#ArrT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Arr<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ArrT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ArrT.cs#L151" class="link">Source</a>
<a href="#ArrT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Arr<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ArrT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ArrT.cs#L162" class="link">Source</a>
<a href="#ArrT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Arr<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ArrT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ArrT.cs#L173" class="link">Source</a>
<a href="#ArrT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Arr<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ArrT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ArrT.cs#L184" class="link">Source</a>
<a href="#ArrT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Arr<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ArrT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ArrT.cs#L196" class="link">Source</a>
<a href="#ArrT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_EffPureT_0" class="def">EffPureT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffPureT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_EffPureT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffPureT.cs#L19" class="link">Source</a>
<a href="#EffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EffPureT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffPureT.cs#L30" class="link">Source</a>
<a href="#EffPureT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EffPureT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffPureT.cs#L41" class="link">Source</a>
<a href="#EffPureT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffPureT.cs#L52" class="link">Source</a>
<a href="#EffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffPureT.cs#L63" class="link">Source</a>
<a href="#EffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffPureT.cs#L74" class="link">Source</a>
<a href="#EffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffPureT.cs#L85" class="link">Source</a>
<a href="#EffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffPureT.cs#L96" class="link">Source</a>
<a href="#EffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffPureT.cs#L107" class="link">Source</a>
<a href="#EffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffPureT.cs#L118" class="link">Source</a>
<a href="#EffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffPureT.cs#L129" class="link">Source</a>
<a href="#EffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffPureT.cs#L140" class="link">Source</a>
<a href="#EffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Que<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffPureT.cs#L151" class="link">Source</a>
<a href="#EffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffPureT.cs#L162" class="link">Source</a>
<a href="#EffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffPureT.cs#L173" class="link">Source</a>
<a href="#EffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EffPureT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffPureT.cs#L184" class="link">Source</a>
<a href="#EffPureT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EffPureT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffPureT.cs#L195" class="link">Source</a>
<a href="#EffPureT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EffPureT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffPureT.cs#L206" class="link">Source</a>
<a href="#EffPureT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_AffT_0" class="def">AffT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_AffT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffT.cs#L19" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffT.cs#L30" class="link">Source</a>
<a href="#AffT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffT.cs#L41" class="link">Source</a>
<a href="#AffT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffT.cs#L52" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffT.cs#L63" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffT.cs#L74" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffT.cs#L85" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffT.cs#L96" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffT.cs#L107" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffT.cs#L118" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffT.cs#L129" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffT.cs#L140" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Que<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffT.cs#L151" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffT.cs#L162" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffT.cs#L173" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffT.cs#L184" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffT.cs#L195" class="link">Source</a>
<a href="#AffT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_4" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffT.cs#L206" class="link">Source</a>
<a href="#AffT_0_Sequence_4" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct
            </span></div>
<div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="AffT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> mma<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EffT.cs#L219" class="link">Source</a>
<a href="#AffT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_EitherAsyncT_0" class="def">EitherAsyncT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L9" class="link">Source</a>
<a href="#LanguageExt_0_EitherAsyncT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L18" class="link">Source</a>
<a href="#EitherAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L29" class="link">Source</a>
<a href="#EitherAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L40" class="link">Source</a>
<a href="#EitherAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L51" class="link">Source</a>
<a href="#EitherAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L62" class="link">Source</a>
<a href="#EitherAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L73" class="link">Source</a>
<a href="#EitherAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L84" class="link">Source</a>
<a href="#EitherAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L95" class="link">Source</a>
<a href="#EitherAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L106" class="link">Source</a>
<a href="#EitherAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L117" class="link">Source</a>
<a href="#EitherAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L128" class="link">Source</a>
<a href="#EitherAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L139" class="link">Source</a>
<a href="#EitherAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L150" class="link">Source</a>
<a href="#EitherAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherAsyncT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L161" class="link">Source</a>
<a href="#EitherAsyncT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryAsync<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L172" class="link">Source</a>
<a href="#EitherAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Task<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L183" class="link">Source</a>
<a href="#EitherAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOptionAsync<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L194" class="link">Source</a>
<a href="#EitherAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionAsync<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L205" class="link">Source</a>
<a href="#EitherAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Aff<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L216" class="link">Source</a>
<a href="#EitherAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherAsyncT.cs#L227" class="link">Source</a>
<a href="#EitherAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_EitherT_0" class="def">EitherT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_EitherT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherT.cs#L19" class="link">Source</a>
<a href="#EitherT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherT.cs#L30" class="link">Source</a>
<a href="#EitherT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherT.cs#L41" class="link">Source</a>
<a href="#EitherT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherT.cs#L52" class="link">Source</a>
<a href="#EitherT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherT.cs#L63" class="link">Source</a>
<a href="#EitherT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherT.cs#L74" class="link">Source</a>
<a href="#EitherT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherT.cs#L85" class="link">Source</a>
<a href="#EitherT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherT.cs#L96" class="link">Source</a>
<a href="#EitherT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherT.cs#L107" class="link">Source</a>
<a href="#EitherT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherT.cs#L118" class="link">Source</a>
<a href="#EitherT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherT.cs#L129" class="link">Source</a>
<a href="#EitherT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherT.cs#L140" class="link">Source</a>
<a href="#EitherT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherT.cs#L151" class="link">Source</a>
<a href="#EitherT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherT.cs#L162" class="link">Source</a>
<a href="#EitherT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherT.cs#L173" class="link">Source</a>
<a href="#EitherT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Either<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Either<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherT.cs#L184" class="link">Source</a>
<a href="#EitherT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherT.cs#L196" class="link">Source</a>
<a href="#EitherT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_EitherUnsafeT_0" class="def">EitherUnsafeT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherUnsafeT.cs#L9" class="link">Source</a>
<a href="#LanguageExt_0_EitherUnsafeT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherUnsafeT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherUnsafeT.cs#L18" class="link">Source</a>
<a href="#EitherUnsafeT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherUnsafeT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherUnsafeT.cs#L29" class="link">Source</a>
<a href="#EitherUnsafeT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherUnsafeT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherUnsafeT.cs#L40" class="link">Source</a>
<a href="#EitherUnsafeT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherUnsafeT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherUnsafeT.cs#L51" class="link">Source</a>
<a href="#EitherUnsafeT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherUnsafeT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherUnsafeT.cs#L62" class="link">Source</a>
<a href="#EitherUnsafeT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherUnsafeT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherUnsafeT.cs#L73" class="link">Source</a>
<a href="#EitherUnsafeT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherUnsafeT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherUnsafeT.cs#L84" class="link">Source</a>
<a href="#EitherUnsafeT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherUnsafeT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherUnsafeT.cs#L95" class="link">Source</a>
<a href="#EitherUnsafeT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherUnsafeT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherUnsafeT.cs#L106" class="link">Source</a>
<a href="#EitherUnsafeT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherUnsafeT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherUnsafeT.cs#L117" class="link">Source</a>
<a href="#EitherUnsafeT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherUnsafeT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherUnsafeT.cs#L128" class="link">Source</a>
<a href="#EitherUnsafeT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherUnsafeT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherUnsafeT.cs#L139" class="link">Source</a>
<a href="#EitherUnsafeT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherUnsafeT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherUnsafeT.cs#L150" class="link">Source</a>
<a href="#EitherUnsafeT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherUnsafeT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherUnsafeT.cs#L161" class="link">Source</a>
<a href="#EitherUnsafeT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherUnsafeT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherUnsafeT.cs#L172" class="link">Source</a>
<a href="#EitherUnsafeT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="EitherUnsafeT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/EitherUnsafeT.cs#L183" class="link">Source</a>
<a href="#EitherUnsafeT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_FinT_0" class="def">FinT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/FinT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_FinT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Fin<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="FinT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/FinT.cs#L19" class="link">Source</a>
<a href="#FinT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Fin<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="FinT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/FinT.cs#L30" class="link">Source</a>
<a href="#FinT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Fin<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="FinT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/FinT.cs#L41" class="link">Source</a>
<a href="#FinT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Fin<span class='generics'>&lt;</span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="FinT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/FinT.cs#L52" class="link">Source</a>
<a href="#FinT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Fin<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="FinT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/FinT.cs#L63" class="link">Source</a>
<a href="#FinT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Fin<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="FinT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/FinT.cs#L74" class="link">Source</a>
<a href="#FinT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Fin<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="FinT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/FinT.cs#L85" class="link">Source</a>
<a href="#FinT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Fin<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="FinT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/FinT.cs#L96" class="link">Source</a>
<a href="#FinT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Fin<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="FinT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/FinT.cs#L107" class="link">Source</a>
<a href="#FinT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Fin<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="FinT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/FinT.cs#L118" class="link">Source</a>
<a href="#FinT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Fin<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="FinT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/FinT.cs#L129" class="link">Source</a>
<a href="#FinT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Fin<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="FinT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/FinT.cs#L140" class="link">Source</a>
<a href="#FinT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Fin<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="FinT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/FinT.cs#L151" class="link">Source</a>
<a href="#FinT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Fin<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="FinT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/FinT.cs#L162" class="link">Source</a>
<a href="#FinT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Fin<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="FinT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/FinT.cs#L173" class="link">Source</a>
<a href="#FinT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Fin<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="FinT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/FinT.cs#L184" class="link">Source</a>
<a href="#FinT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Fin<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="FinT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/FinT.cs#L196" class="link">Source</a>
<a href="#FinT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_HashSetT_0" class="def">HashSetT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/HashSetT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_HashSetT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
HashSet<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="HashSetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/HashSetT.cs#L19" class="link">Source</a>
<a href="#HashSetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
HashSet<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="HashSetT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/HashSetT.cs#L30" class="link">Source</a>
<a href="#HashSetT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
HashSet<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="HashSetT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/HashSetT.cs#L41" class="link">Source</a>
<a href="#HashSetT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
HashSet<span class='generics'>&lt;</span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="HashSetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/HashSetT.cs#L52" class="link">Source</a>
<a href="#HashSetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
HashSet<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="HashSetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/HashSetT.cs#L63" class="link">Source</a>
<a href="#HashSetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
HashSet<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="HashSetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/HashSetT.cs#L74" class="link">Source</a>
<a href="#HashSetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
HashSet<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="HashSetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/HashSetT.cs#L85" class="link">Source</a>
<a href="#HashSetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
HashSet<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="HashSetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/HashSetT.cs#L96" class="link">Source</a>
<a href="#HashSetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
HashSet<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="HashSetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/HashSetT.cs#L107" class="link">Source</a>
<a href="#HashSetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
HashSet<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="HashSetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/HashSetT.cs#L118" class="link">Source</a>
<a href="#HashSetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
HashSet<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="HashSetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/HashSetT.cs#L129" class="link">Source</a>
<a href="#HashSetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
HashSet<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="HashSetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/HashSetT.cs#L140" class="link">Source</a>
<a href="#HashSetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
HashSet<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="HashSetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/HashSetT.cs#L151" class="link">Source</a>
<a href="#HashSetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
HashSet<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="HashSetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/HashSetT.cs#L162" class="link">Source</a>
<a href="#HashSetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
HashSet<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="HashSetT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/HashSetT.cs#L173" class="link">Source</a>
<a href="#HashSetT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
HashSet<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="HashSetT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/HashSetT.cs#L184" class="link">Source</a>
<a href="#HashSetT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
HashSet<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="HashSetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/HashSetT.cs#L196" class="link">Source</a>
<a href="#HashSetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_IEnumerableT_0" class="def">IEnumerableT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/IEnumerableT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_IEnumerableT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
IEnumerable<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="IEnumerableT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/IEnumerableT.cs#L19" class="link">Source</a>
<a href="#IEnumerableT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
IEnumerable<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="IEnumerableT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/IEnumerableT.cs#L30" class="link">Source</a>
<a href="#IEnumerableT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
IEnumerable<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="IEnumerableT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/IEnumerableT.cs#L41" class="link">Source</a>
<a href="#IEnumerableT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
IEnumerable<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="IEnumerableT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/IEnumerableT.cs#L52" class="link">Source</a>
<a href="#IEnumerableT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
IEnumerable<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="IEnumerableT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/IEnumerableT.cs#L63" class="link">Source</a>
<a href="#IEnumerableT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
IEnumerable<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="IEnumerableT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/IEnumerableT.cs#L74" class="link">Source</a>
<a href="#IEnumerableT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
IEnumerable<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="IEnumerableT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/IEnumerableT.cs#L85" class="link">Source</a>
<a href="#IEnumerableT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
IEnumerable<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="IEnumerableT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/IEnumerableT.cs#L96" class="link">Source</a>
<a href="#IEnumerableT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
IEnumerable<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="IEnumerableT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/IEnumerableT.cs#L107" class="link">Source</a>
<a href="#IEnumerableT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
IEnumerable<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="IEnumerableT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Que<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/IEnumerableT.cs#L118" class="link">Source</a>
<a href="#IEnumerableT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
IEnumerable<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="IEnumerableT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/IEnumerableT.cs#L129" class="link">Source</a>
<a href="#IEnumerableT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
IEnumerable<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="IEnumerableT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/IEnumerableT.cs#L140" class="link">Source</a>
<a href="#IEnumerableT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
IEnumerable<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="IEnumerableT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/IEnumerableT.cs#L151" class="link">Source</a>
<a href="#IEnumerableT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
IEnumerable<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="IEnumerableT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/IEnumerableT.cs#L162" class="link">Source</a>
<a href="#IEnumerableT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
IEnumerable<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="IEnumerableT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/IEnumerableT.cs#L173" class="link">Source</a>
<a href="#IEnumerableT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
IEnumerable<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="IEnumerableT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/IEnumerableT.cs#L184" class="link">Source</a>
<a href="#IEnumerableT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
IEnumerable<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="IEnumerableT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/IEnumerableT.cs#L195" class="link">Source</a>
<a href="#IEnumerableT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;Fail&gt;, Eq&lt;Fail&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
IEnumerable<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="IEnumerableT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/IEnumerableT.cs#L207" class="link">Source</a>
<a href="#IEnumerableT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_LstT_0" class="def">LstT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/LstT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_LstT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Lst<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="LstT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/LstT.cs#L19" class="link">Source</a>
<a href="#LstT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Lst<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="LstT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/LstT.cs#L30" class="link">Source</a>
<a href="#LstT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Lst<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="LstT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/LstT.cs#L41" class="link">Source</a>
<a href="#LstT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Lst<span class='generics'>&lt;</span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="LstT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/LstT.cs#L52" class="link">Source</a>
<a href="#LstT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Lst<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="LstT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/LstT.cs#L63" class="link">Source</a>
<a href="#LstT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Lst<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="LstT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/LstT.cs#L74" class="link">Source</a>
<a href="#LstT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Lst<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="LstT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/LstT.cs#L85" class="link">Source</a>
<a href="#LstT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Lst<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="LstT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/LstT.cs#L96" class="link">Source</a>
<a href="#LstT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Lst<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="LstT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/LstT.cs#L107" class="link">Source</a>
<a href="#LstT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Lst<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="LstT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/LstT.cs#L118" class="link">Source</a>
<a href="#LstT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Lst<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="LstT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/LstT.cs#L129" class="link">Source</a>
<a href="#LstT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Lst<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="LstT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/LstT.cs#L140" class="link">Source</a>
<a href="#LstT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Lst<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="LstT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/LstT.cs#L151" class="link">Source</a>
<a href="#LstT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Lst<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="LstT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/LstT.cs#L162" class="link">Source</a>
<a href="#LstT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Lst<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="LstT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/LstT.cs#L173" class="link">Source</a>
<a href="#LstT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Lst<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="LstT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/LstT.cs#L184" class="link">Source</a>
<a href="#LstT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Lst<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="LstT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/LstT.cs#L196" class="link">Source</a>
<a href="#LstT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_OptionAsyncT_0" class="def">OptionAsyncT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_OptionAsyncT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L19" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L30" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L41" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L52" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L63" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L74" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionAsync<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L85" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L96" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L107" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L118" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L129" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L140" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L151" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>
            this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L162" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryAsync<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L175" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Task<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L186" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOptionAsync<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L197" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L208" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L219" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Aff<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L230" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionAsync<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionAsyncT.cs#L241" class="link">Source</a>
<a href="#OptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_OptionT_0" class="def">OptionT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_OptionT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionT.cs#L19" class="link">Source</a>
<a href="#OptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionT.cs#L30" class="link">Source</a>
<a href="#OptionT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionT.cs#L41" class="link">Source</a>
<a href="#OptionT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionT.cs#L52" class="link">Source</a>
<a href="#OptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionT.cs#L63" class="link">Source</a>
<a href="#OptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionT.cs#L74" class="link">Source</a>
<a href="#OptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionT.cs#L85" class="link">Source</a>
<a href="#OptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionT.cs#L96" class="link">Source</a>
<a href="#OptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionT.cs#L107" class="link">Source</a>
<a href="#OptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionT.cs#L118" class="link">Source</a>
<a href="#OptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionT.cs#L129" class="link">Source</a>
<a href="#OptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionT.cs#L140" class="link">Source</a>
<a href="#OptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionT.cs#L151" class="link">Source</a>
<a href="#OptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionT.cs#L162" class="link">Source</a>
<a href="#OptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionT.cs#L173" class="link">Source</a>
<a href="#OptionT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionT.cs#L184" class="link">Source</a>
<a href="#OptionT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionT.cs#L196" class="link">Source</a>
<a href="#OptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_OptionUnsafeT_0" class="def">OptionUnsafeT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionUnsafeT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_OptionUnsafeT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionUnsafe<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionUnsafeT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionUnsafeT.cs#L19" class="link">Source</a>
<a href="#OptionUnsafeT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionUnsafe<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionUnsafeT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionUnsafeT.cs#L30" class="link">Source</a>
<a href="#OptionUnsafeT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionUnsafe<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionUnsafeT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionUnsafeT.cs#L41" class="link">Source</a>
<a href="#OptionUnsafeT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionUnsafe<span class='generics'>&lt;</span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionUnsafeT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionUnsafeT.cs#L52" class="link">Source</a>
<a href="#OptionUnsafeT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionUnsafe<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionUnsafeT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionUnsafeT.cs#L63" class="link">Source</a>
<a href="#OptionUnsafeT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionUnsafe<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionUnsafeT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionUnsafeT.cs#L74" class="link">Source</a>
<a href="#OptionUnsafeT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionUnsafe<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionUnsafeT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionUnsafeT.cs#L85" class="link">Source</a>
<a href="#OptionUnsafeT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionUnsafe<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionUnsafeT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionUnsafeT.cs#L96" class="link">Source</a>
<a href="#OptionUnsafeT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionUnsafe<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionUnsafeT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionUnsafeT.cs#L107" class="link">Source</a>
<a href="#OptionUnsafeT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionUnsafe<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionUnsafeT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionUnsafeT.cs#L118" class="link">Source</a>
<a href="#OptionUnsafeT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionUnsafe<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionUnsafeT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionUnsafeT.cs#L129" class="link">Source</a>
<a href="#OptionUnsafeT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionUnsafe<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionUnsafeT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionUnsafeT.cs#L140" class="link">Source</a>
<a href="#OptionUnsafeT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionUnsafe<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionUnsafeT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionUnsafeT.cs#L151" class="link">Source</a>
<a href="#OptionUnsafeT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionUnsafe<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionUnsafeT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionUnsafeT.cs#L162" class="link">Source</a>
<a href="#OptionUnsafeT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionUnsafe<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionUnsafeT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionUnsafeT.cs#L173" class="link">Source</a>
<a href="#OptionUnsafeT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionUnsafe<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionUnsafeT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionUnsafeT.cs#L184" class="link">Source</a>
<a href="#OptionUnsafeT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
OptionUnsafe<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="OptionUnsafeT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/OptionUnsafeT.cs#L196" class="link">Source</a>
<a href="#OptionUnsafeT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_QueT_0" class="def">QueT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/QueT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_QueT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Que<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="QueT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/QueT.cs#L19" class="link">Source</a>
<a href="#QueT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Que<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="QueT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/QueT.cs#L30" class="link">Source</a>
<a href="#QueT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Que<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="QueT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/QueT.cs#L41" class="link">Source</a>
<a href="#QueT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Que<span class='generics'>&lt;</span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="QueT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/QueT.cs#L52" class="link">Source</a>
<a href="#QueT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Que<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="QueT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/QueT.cs#L63" class="link">Source</a>
<a href="#QueT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Que<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="QueT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/QueT.cs#L74" class="link">Source</a>
<a href="#QueT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Que<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="QueT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/QueT.cs#L85" class="link">Source</a>
<a href="#QueT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Que<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="QueT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/QueT.cs#L96" class="link">Source</a>
<a href="#QueT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Que<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="QueT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/QueT.cs#L107" class="link">Source</a>
<a href="#QueT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Que<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="QueT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/QueT.cs#L118" class="link">Source</a>
<a href="#QueT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Que<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="QueT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/QueT.cs#L129" class="link">Source</a>
<a href="#QueT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Que<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="QueT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/QueT.cs#L140" class="link">Source</a>
<a href="#QueT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Que<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="QueT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/QueT.cs#L151" class="link">Source</a>
<a href="#QueT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Que<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="QueT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/QueT.cs#L162" class="link">Source</a>
<a href="#QueT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Que<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="QueT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Que<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/QueT.cs#L174" class="link">Source</a>
<a href="#QueT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_ReaderT_0" class="def">ReaderT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ReaderT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_ReaderT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ReaderT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ReaderT.cs#L19" class="link">Source</a>
<a href="#ReaderT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ReaderT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ReaderT.cs#L30" class="link">Source</a>
<a href="#ReaderT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ReaderT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ReaderT.cs#L41" class="link">Source</a>
<a href="#ReaderT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A[]<span class='generics'>&gt;</span>
<a id="ReaderT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span>[] ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ReaderT.cs#L52" class="link">Source</a>
<a href="#ReaderT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ReaderT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ReaderT.cs#L63" class="link">Source</a>
<a href="#ReaderT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ReaderT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ReaderT.cs#L74" class="link">Source</a>
<a href="#ReaderT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ReaderT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ReaderT.cs#L85" class="link">Source</a>
<a href="#ReaderT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ReaderT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Reader<span class='generics'>&lt;</span>Env<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ReaderT.cs#L96" class="link">Source</a>
<a href="#ReaderT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_RwsT_0" class="def">RwsT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/RWST.cs#L11" class="link">Source</a>
<a href="#LanguageExt_0_RwsT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="RwsT_0_Sequence_5" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/RWST.cs#L20" class="link">Source</a>
<a href="#RwsT_0_Sequence_5" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidW : struct, Monoid&lt;W&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="RwsT_0_Sequence_5" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/RWST.cs#L31" class="link">Source</a>
<a href="#RwsT_0_Sequence_5" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidW : struct, Monoid&lt;W&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="RwsT_0_Sequence_5" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/RWST.cs#L42" class="link">Source</a>
<a href="#RwsT_0_Sequence_5" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidW : struct, Monoid&lt;W&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A[]<span class='generics'>&gt;</span>
<a id="RwsT_0_Sequence_5" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>[] ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/RWST.cs#L53" class="link">Source</a>
<a href="#RwsT_0_Sequence_5" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidW : struct, Monoid&lt;W&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="RwsT_0_Sequence_5" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/RWST.cs#L64" class="link">Source</a>
<a href="#RwsT_0_Sequence_5" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidW : struct, Monoid&lt;W&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="RwsT_0_Sequence_5" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/RWST.cs#L75" class="link">Source</a>
<a href="#RwsT_0_Sequence_5" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidW : struct, Monoid&lt;W&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="RwsT_0_Sequence_5" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/RWST.cs#L86" class="link">Source</a>
<a href="#RwsT_0_Sequence_5" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidW : struct, Monoid&lt;W&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="RwsT_0_Sequence_5" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>RWS<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>R<span class='comma'>, </span>W<span class='comma'>, </span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/RWST.cs#L97" class="link">Source</a>
<a href="#RwsT_0_Sequence_5" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidW : struct, Monoid&lt;W&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_SeqT_0" class="def">SeqT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SeqT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_SeqT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Seq<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SeqT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SeqT.cs#L19" class="link">Source</a>
<a href="#SeqT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Seq<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SeqT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SeqT.cs#L30" class="link">Source</a>
<a href="#SeqT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Seq<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SeqT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SeqT.cs#L41" class="link">Source</a>
<a href="#SeqT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Seq<span class='generics'>&lt;</span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SeqT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SeqT.cs#L52" class="link">Source</a>
<a href="#SeqT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Seq<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SeqT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SeqT.cs#L63" class="link">Source</a>
<a href="#SeqT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Seq<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SeqT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SeqT.cs#L74" class="link">Source</a>
<a href="#SeqT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Seq<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SeqT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SeqT.cs#L85" class="link">Source</a>
<a href="#SeqT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Seq<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SeqT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SeqT.cs#L96" class="link">Source</a>
<a href="#SeqT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Seq<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SeqT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SeqT.cs#L107" class="link">Source</a>
<a href="#SeqT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Seq<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SeqT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SeqT.cs#L118" class="link">Source</a>
<a href="#SeqT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Seq<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SeqT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SeqT.cs#L129" class="link">Source</a>
<a href="#SeqT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Seq<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SeqT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SeqT.cs#L140" class="link">Source</a>
<a href="#SeqT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Seq<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SeqT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SeqT.cs#L151" class="link">Source</a>
<a href="#SeqT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Seq<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SeqT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SeqT.cs#L162" class="link">Source</a>
<a href="#SeqT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Seq<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SeqT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SeqT.cs#L173" class="link">Source</a>
<a href="#SeqT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Seq<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SeqT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SeqT.cs#L184" class="link">Source</a>
<a href="#SeqT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Seq<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SeqT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SeqT.cs#L196" class="link">Source</a>
<a href="#SeqT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_SetT_0" class="def">SetT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SetT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_SetT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Set<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SetT.cs#L19" class="link">Source</a>
<a href="#SetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Set<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SetT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SetT.cs#L30" class="link">Source</a>
<a href="#SetT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Set<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SetT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SetT.cs#L41" class="link">Source</a>
<a href="#SetT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Set<span class='generics'>&lt;</span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SetT.cs#L52" class="link">Source</a>
<a href="#SetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Set<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SetT.cs#L63" class="link">Source</a>
<a href="#SetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Set<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SetT.cs#L74" class="link">Source</a>
<a href="#SetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Set<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SetT.cs#L85" class="link">Source</a>
<a href="#SetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Set<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SetT.cs#L96" class="link">Source</a>
<a href="#SetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Set<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SetT.cs#L107" class="link">Source</a>
<a href="#SetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Set<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SetT.cs#L118" class="link">Source</a>
<a href="#SetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Set<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SetT.cs#L129" class="link">Source</a>
<a href="#SetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Set<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SetT.cs#L140" class="link">Source</a>
<a href="#SetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Set<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SetT.cs#L151" class="link">Source</a>
<a href="#SetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Set<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SetT.cs#L162" class="link">Source</a>
<a href="#SetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Set<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SetT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SetT.cs#L173" class="link">Source</a>
<a href="#SetT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Set<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SetT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SetT.cs#L184" class="link">Source</a>
<a href="#SetT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Set<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="SetT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/SetT.cs#L196" class="link">Source</a>
<a href="#SetT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_StateT_0" class="def">StateT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StateT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_StateT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
State<span class='generics'>&lt;</span>S<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StateT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>State<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StateT.cs#L19" class="link">Source</a>
<a href="#StateT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
State<span class='generics'>&lt;</span>S<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StateT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>State<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StateT.cs#L30" class="link">Source</a>
<a href="#StateT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
State<span class='generics'>&lt;</span>S<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StateT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>State<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StateT.cs#L41" class="link">Source</a>
<a href="#StateT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
State<span class='generics'>&lt;</span>S<span class='comma'>, </span>A[]<span class='generics'>&gt;</span>
<a id="StateT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this State<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>[] ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StateT.cs#L52" class="link">Source</a>
<a href="#StateT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
State<span class='generics'>&lt;</span>S<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StateT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>State<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StateT.cs#L63" class="link">Source</a>
<a href="#StateT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
State<span class='generics'>&lt;</span>S<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StateT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>State<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StateT.cs#L74" class="link">Source</a>
<a href="#StateT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
State<span class='generics'>&lt;</span>S<span class='comma'>, </span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StateT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>State<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StateT.cs#L85" class="link">Source</a>
<a href="#StateT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
State<span class='generics'>&lt;</span>S<span class='comma'>, </span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StateT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>State<span class='generics'>&lt;</span>S<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StateT.cs#L96" class="link">Source</a>
<a href="#StateT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_StckT_0" class="def">StckT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StckT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_StckT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Stck<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StckT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StckT.cs#L19" class="link">Source</a>
<a href="#StckT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Stck<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StckT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StckT.cs#L30" class="link">Source</a>
<a href="#StckT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Stck<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StckT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StckT.cs#L41" class="link">Source</a>
<a href="#StckT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Stck<span class='generics'>&lt;</span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StckT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StckT.cs#L52" class="link">Source</a>
<a href="#StckT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Stck<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StckT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StckT.cs#L63" class="link">Source</a>
<a href="#StckT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Stck<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StckT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StckT.cs#L74" class="link">Source</a>
<a href="#StckT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Stck<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StckT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StckT.cs#L85" class="link">Source</a>
<a href="#StckT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Stck<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StckT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StckT.cs#L96" class="link">Source</a>
<a href="#StckT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Stck<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StckT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StckT.cs#L107" class="link">Source</a>
<a href="#StckT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Stck<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StckT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StckT.cs#L118" class="link">Source</a>
<a href="#StckT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Stck<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StckT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StckT.cs#L129" class="link">Source</a>
<a href="#StckT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Stck<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StckT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StckT.cs#L140" class="link">Source</a>
<a href="#StckT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Stck<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StckT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StckT.cs#L151" class="link">Source</a>
<a href="#StckT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Stck<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StckT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StckT.cs#L162" class="link">Source</a>
<a href="#StckT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Stck<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="StckT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/StckT.cs#L174" class="link">Source</a>
<a href="#StckT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_TaskT_0" class="def">TaskT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TaskT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_TaskT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TaskT.cs#L19" class="link">Source</a>
<a href="#TaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TaskT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TaskT.cs#L30" class="link">Source</a>
<a href="#TaskT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TaskT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TaskT.cs#L41" class="link">Source</a>
<a href="#TaskT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TaskT.cs#L52" class="link">Source</a>
<a href="#TaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Task<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TaskT.cs#L63" class="link">Source</a>
<a href="#TaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TaskT.cs#L74" class="link">Source</a>
<a href="#TaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TaskT.cs#L85" class="link">Source</a>
<a href="#TaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TaskT.cs#L96" class="link">Source</a>
<a href="#TaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TaskT.cs#L107" class="link">Source</a>
<a href="#TaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TaskT.cs#L118" class="link">Source</a>
<a href="#TaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TaskT.cs#L129" class="link">Source</a>
<a href="#TaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TaskT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TaskT.cs#L140" class="link">Source</a>
<a href="#TaskT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TaskT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TaskT.cs#L151" class="link">Source</a>
<a href="#TaskT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryAsync<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TaskT.cs#L163" class="link">Source</a>
<a href="#TaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionAsync<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TaskT.cs#L174" class="link">Source</a>
<a href="#TaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOptionAsync<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TaskT.cs#L185" class="link">Source</a>
<a href="#TaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TaskT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TaskT.cs#L196" class="link">Source</a>
<a href="#TaskT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Aff<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TaskT.cs#L207" class="link">Source</a>
<a href="#TaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TaskT.cs#L218" class="link">Source</a>
<a href="#TaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_TryAsyncT_0" class="def">TryAsyncT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_TryAsyncT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L19" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L30" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L41" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L52" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L63" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryAsync<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L74" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L85" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L96" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L107" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L118" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L129" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L140" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L151" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L162" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L173" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Task<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L185" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionAsync<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L196" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOptionAsync<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L207" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L218" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Aff<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L229" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryAsync<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryAsyncT.cs#L240" class="link">Source</a>
<a href="#TryAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_TryOptionAsyncT_0" class="def">TryOptionAsyncT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_TryOptionAsyncT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L19" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L30" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L41" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L52" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L63" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryAsync<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L74" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L85" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L96" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L107" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L118" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L129" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L140" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L151" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L162" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L173" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Task<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L185" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionAsync<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L196" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOptionAsync<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L207" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L218" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Aff<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L229" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOptionAsync<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionAsyncT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionAsyncT.cs#L240" class="link">Source</a>
<a href="#TryOptionAsyncT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_TryOptionT_0" class="def">TryOptionT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_TryOptionT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOption<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionT.cs#L19" class="link">Source</a>
<a href="#TryOptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOption<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionT.cs#L30" class="link">Source</a>
<a href="#TryOptionT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOption<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionT.cs#L41" class="link">Source</a>
<a href="#TryOptionT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOption<span class='generics'>&lt;</span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionT.cs#L52" class="link">Source</a>
<a href="#TryOptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOption<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionT.cs#L63" class="link">Source</a>
<a href="#TryOptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOption<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionT.cs#L74" class="link">Source</a>
<a href="#TryOptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOption<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionT.cs#L85" class="link">Source</a>
<a href="#TryOptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOption<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionT.cs#L96" class="link">Source</a>
<a href="#TryOptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOption<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionT.cs#L107" class="link">Source</a>
<a href="#TryOptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOption<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionT.cs#L118" class="link">Source</a>
<a href="#TryOptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOption<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionT.cs#L129" class="link">Source</a>
<a href="#TryOptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOption<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionT.cs#L140" class="link">Source</a>
<a href="#TryOptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOption<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionT.cs#L151" class="link">Source</a>
<a href="#TryOptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOption<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionT.cs#L162" class="link">Source</a>
<a href="#TryOptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOption<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionT.cs#L173" class="link">Source</a>
<a href="#TryOptionT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOption<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionT.cs#L184" class="link">Source</a>
<a href="#TryOptionT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
TryOption<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryOptionT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryOptionT.cs#L196" class="link">Source</a>
<a href="#TryOptionT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_TryT_0" class="def">TryT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_TryT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Try<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryT.cs#L19" class="link">Source</a>
<a href="#TryT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Try<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryT.cs#L30" class="link">Source</a>
<a href="#TryT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Try<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryT.cs#L41" class="link">Source</a>
<a href="#TryT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Try<span class='generics'>&lt;</span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryT.cs#L52" class="link">Source</a>
<a href="#TryT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Try<span class='generics'>&lt;</span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryT.cs#L63" class="link">Source</a>
<a href="#TryT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Try<span class='generics'>&lt;</span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryT.cs#L74" class="link">Source</a>
<a href="#TryT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Try<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryT.cs#L85" class="link">Source</a>
<a href="#TryT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Try<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryT.cs#L96" class="link">Source</a>
<a href="#TryT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Try<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryT.cs#L107" class="link">Source</a>
<a href="#TryT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Try<span class='generics'>&lt;</span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryT.cs#L118" class="link">Source</a>
<a href="#TryT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Try<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryT.cs#L129" class="link">Source</a>
<a href="#TryT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Try<span class='generics'>&lt;</span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryT.cs#L140" class="link">Source</a>
<a href="#TryT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Try<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryT.cs#L151" class="link">Source</a>
<a href="#TryT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Try<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryT.cs#L162" class="link">Source</a>
<a href="#TryT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Try<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryT.cs#L173" class="link">Source</a>
<a href="#TryT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Try<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryT.cs#L184" class="link">Source</a>
<a href="#TryT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Try<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="TryT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/TryT.cs#L196" class="link">Source</a>
<a href="#TryT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_ValidationT_0" class="def">ValidationT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationSeqT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_ValidationT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationSeqT.cs#L19" class="link">Source</a>
<a href="#ValidationT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Either<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationSeqT.cs#L30" class="link">Source</a>
<a href="#ValidationT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>EitherUnsafe<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationSeqT.cs#L41" class="link">Source</a>
<a href="#ValidationT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationSeqT.cs#L52" class="link">Source</a>
<a href="#ValidationT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationSeqT.cs#L63" class="link">Source</a>
<a href="#ValidationT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationSeqT.cs#L74" class="link">Source</a>
<a href="#ValidationT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationSeqT.cs#L85" class="link">Source</a>
<a href="#ValidationT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationSeqT.cs#L96" class="link">Source</a>
<a href="#ValidationT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationSeqT.cs#L107" class="link">Source</a>
<a href="#ValidationT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationSeqT.cs#L118" class="link">Source</a>
<a href="#ValidationT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationSeqT.cs#L129" class="link">Source</a>
<a href="#ValidationT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationSeqT.cs#L140" class="link">Source</a>
<a href="#ValidationT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationSeqT.cs#L151" class="link">Source</a>
<a href="#ValidationT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationSeqT.cs#L162" class="link">Source</a>
<a href="#ValidationT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationSeqT.cs#L173" class="link">Source</a>
<a href="#ValidationT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationSeqT.cs#L184" class="link">Source</a>
<a href="#ValidationT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;Fail&gt;, Eq&lt;Fail&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationSeqT.cs#L196" class="link">Source</a>
<a href="#ValidationT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_ValidationT_0" class="def">ValidationT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_ValidationT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationT.cs#L19" class="link">Source</a>
<a href="#ValidationT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;Fail&gt;, Eq&lt;Fail&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>Either<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationT.cs#L31" class="link">Source</a>
<a href="#ValidationT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;Fail&gt;, Eq&lt;Fail&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>EitherUnsafe<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationT.cs#L43" class="link">Source</a>
<a href="#ValidationT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;Fail&gt;, Eq&lt;Fail&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationT.cs#L55" class="link">Source</a>
<a href="#ValidationT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;Fail&gt;, Eq&lt;Fail&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationT.cs#L67" class="link">Source</a>
<a href="#ValidationT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;Fail&gt;, Eq&lt;Fail&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationT.cs#L79" class="link">Source</a>
<a href="#ValidationT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;Fail&gt;, Eq&lt;Fail&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationT.cs#L91" class="link">Source</a>
<a href="#ValidationT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;Fail&gt;, Eq&lt;Fail&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationT.cs#L103" class="link">Source</a>
<a href="#ValidationT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;Fail&gt;, Eq&lt;Fail&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationT.cs#L115" class="link">Source</a>
<a href="#ValidationT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;Fail&gt;, Eq&lt;Fail&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationT.cs#L127" class="link">Source</a>
<a href="#ValidationT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;Fail&gt;, Eq&lt;Fail&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationT.cs#L139" class="link">Source</a>
<a href="#ValidationT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;Fail&gt;, Eq&lt;Fail&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationT.cs#L151" class="link">Source</a>
<a href="#ValidationT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;Fail&gt;, Eq&lt;Fail&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationT.cs#L163" class="link">Source</a>
<a href="#ValidationT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;Fail&gt;, Eq&lt;Fail&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationT.cs#L175" class="link">Source</a>
<a href="#ValidationT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;Fail&gt;, Eq&lt;Fail&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>Fail<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationT.cs#L187" class="link">Source</a>
<a href="#ValidationT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;Fail&gt;, Eq&lt;Fail&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationT.cs#L199" class="link">Source</a>
<a href="#ValidationT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;Fail&gt;, Eq&lt;Fail&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValidationT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>Fail<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValidationT.cs#L211" class="link">Source</a>
<a href="#ValidationT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;Fail&gt;, Eq&lt;Fail&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_ValueTaskT_0" class="def">ValueTaskT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValueTaskT.cs#L10" class="link">Source</a>
<a href="#LanguageExt_0_ValueTaskT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValueTaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValueTaskT.cs#L19" class="link">Source</a>
<a href="#ValueTaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValueTaskT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Either<span class='generics'>&lt;</span>L<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValueTaskT.cs#L30" class="link">Source</a>
<a href="#ValueTaskT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValueTaskT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherUnsafe<span class='generics'>&lt;</span>L<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValueTaskT.cs#L41" class="link">Source</a>
<a href="#ValueTaskT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Identity<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValueTaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Identity<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValueTaskT.cs#L52" class="link">Source</a>
<a href="#ValueTaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValueTaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this ValueTask<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValueTaskT.cs#L63" class="link">Source</a>
<a href="#ValueTaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Fin<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValueTaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Fin<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValueTaskT.cs#L74" class="link">Source</a>
<a href="#ValueTaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValueTaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Option<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValueTaskT.cs#L85" class="link">Source</a>
<a href="#ValueTaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>OptionUnsafe<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValueTaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionUnsafe<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValueTaskT.cs#L96" class="link">Source</a>
<a href="#ValueTaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValueTaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValueTaskT.cs#L107" class="link">Source</a>
<a href="#ValueTaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Try<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValueTaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Try<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValueTaskT.cs#L118" class="link">Source</a>
<a href="#ValueTaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>TryOption<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValueTaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOption<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValueTaskT.cs#L129" class="link">Source</a>
<a href="#ValueTaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValueTaskT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>FAIL<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValueTaskT.cs#L140" class="link">Source</a>
<a href="#ValueTaskT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValueTaskT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Validation<span class='generics'>&lt;</span>MonoidFail<span class='comma'>, </span>FAIL<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValueTaskT.cs#L151" class="link">Source</a>
<a href="#ValueTaskT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidFail : struct, Monoid&lt;FAIL&gt;, Eq&lt;FAIL&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>TryAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValueTaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryAsync<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValueTaskT.cs#L163" class="link">Source</a>
<a href="#ValueTaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>OptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValueTaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this OptionAsync<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValueTaskT.cs#L174" class="link">Source</a>
<a href="#ValueTaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>TryOptionAsync<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValueTaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this TryOptionAsync<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValueTaskT.cs#L185" class="link">Source</a>
<a href="#ValueTaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValueTaskT_0_Sequence_2" class="def">Sequence</a>
<span class='generics'>&lt;</span>L<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this EitherAsync<span class='generics'>&lt;</span>L<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValueTaskT.cs#L196" class="link">Source</a>
<a href="#ValueTaskT_0_Sequence_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValueTaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Aff<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValueTaskT.cs#L207" class="link">Source</a>
<a href="#ValueTaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="ValueTaskT_0_Sequence_1" class="def">Sequence</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Eff<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/ValueTaskT.cs#L218" class="link">Source</a>
<a href="#ValueTaskT_0_Sequence_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_WriterT_0" class="def">WriterT</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/WriterT.cs#L11" class="link">Source</a>
<a href="#LanguageExt_0_WriterT_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>Seq<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="WriterT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Seq<span class='generics'>&lt;</span>Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/WriterT.cs#L20" class="link">Source</a>
<a href="#WriterT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidW : struct, Monoid&lt;W&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>Lst<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="WriterT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Lst<span class='generics'>&lt;</span>Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/WriterT.cs#L31" class="link">Source</a>
<a href="#WriterT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidW : struct, Monoid&lt;W&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>Arr<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="WriterT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Arr<span class='generics'>&lt;</span>Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/WriterT.cs#L42" class="link">Source</a>
<a href="#WriterT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidW : struct, Monoid&lt;W&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A[]<span class='generics'>&gt;</span>
<a id="WriterT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span>[] ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/WriterT.cs#L53" class="link">Source</a>
<a href="#WriterT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidW : struct, Monoid&lt;W&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>Set<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="WriterT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Set<span class='generics'>&lt;</span>Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/WriterT.cs#L64" class="link">Source</a>
<a href="#WriterT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidW : struct, Monoid&lt;W&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>HashSet<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="WriterT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this HashSet<span class='generics'>&lt;</span>Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/WriterT.cs#L75" class="link">Source</a>
<a href="#WriterT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidW : struct, Monoid&lt;W&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>Stck<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="WriterT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Stck<span class='generics'>&lt;</span>Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/WriterT.cs#L86" class="link">Source</a>
<a href="#WriterT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidW : struct, Monoid&lt;W&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>IEnumerable<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="WriterT_0_Sequence_3" class="def">Sequence</a>
<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>Writer<span class='generics'>&lt;</span>MonoidW<span class='comma'>, </span>W<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> ta<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Transformer/Sequence0/WriterT.cs#L97" class="link">Source</a>
<a href="#WriterT_0_Sequence_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> MonoidW : struct, Monoid&lt;W&gt;</span></div></div></p>
<div class="doc"><div><p>Traverses each value in the <code>ta</code> nested monad,  Then applies the monadic rules of the return type
(which is the input nested monad, flipped: so <code>M&lt;N&lt;A&gt;&gt;</code> becomes <code>N&lt;M&lt;A&gt;&gt;</code>).</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">A</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Bound value type</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">ta</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>The subject traversable</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Mapped monad</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div></div></div></body></html>