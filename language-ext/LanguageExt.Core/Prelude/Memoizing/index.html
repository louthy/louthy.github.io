<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>LanguageExt.Core\Prelude\Memoizing</title>
<link href="style.css" rel="stylesheet" type="text/css"/></head>
<body class="js-enabled"><div id="package-header"><ul class="links" id="page-menu"><li><a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Prelude/Memoizing" class="link">Source</a></li>
<li><a href="../index.html" class="link">Contents</a></li>
<li><a href="../../../index.html" class="link">Index</a></li></ul>
<p class="caption">LanguageExt.Core</p></div>
<div id="content"><div id="module-header"><p class="caption"><a href="../../index.html" class="link">LanguageExt.Core</a>
<span> ► </span>
<a href="../index.html" class="link">Prelude</a>
<span> ► </span>
<a href="index.html" class="link">Memoizing</a></p></div>

<div id="table-of-contents"><p class="caption">Contents</p>
<ul><li><a href="#_0_Prelude_0" class="link"><div class="nowrap">Prelude
</div></a></li>
<ul><li><a href="#Prelude_0_memo_1" class="link"><div class="nowrap">memo
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> func<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_memo_2" class="link"><div class="nowrap">memo
<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span> func<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_memoUnsafe_2" class="link"><div class="nowrap">memoUnsafe
<span class='generics'>&lt;</span>T<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>T<span class='comma'>, </span>R<span class='generics'>&gt;</span> func<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_memo_1" class="link"><div class="nowrap">memo
<span class='generics'>&lt;</span>T<span class='generics'>&gt;</span>
<span class='parens'>(</span>IEnumerable<span class='generics'>&lt;</span>T<span class='generics'>&gt;</span> seq<span class='parens'>)</span></div></a></li></ul>
<li><a href="#_0_MemoExtensions_0" class="link"><div class="nowrap">MemoExtensions
</div></a></li>
<ul><li><a href="#MemoExtensions_0_Memo_1" class="link"><div class="nowrap">Memo
<span class='generics'>&lt;</span>T<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Func<span class='generics'>&lt;</span>T<span class='generics'>&gt;</span> func<span class='parens'>)</span></div></a></li>
<li><a href="#MemoExtensions_0_Memo_2" class="link"><div class="nowrap">Memo
<span class='generics'>&lt;</span>T<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Func<span class='generics'>&lt;</span>T<span class='comma'>, </span>R<span class='generics'>&gt;</span> func<span class='parens'>)</span></div></a></li>
<li><a href="#MemoExtensions_0_MemoUnsafe_2" class="link"><div class="nowrap">MemoUnsafe
<span class='generics'>&lt;</span>T<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Func<span class='generics'>&lt;</span>T<span class='comma'>, </span>R<span class='generics'>&gt;</span> func<span class='parens'>)</span></div></a></li>
<li><a href="#MemoExtensions_0_Memo_1" class="link"><div class="nowrap">Memo
<span class='generics'>&lt;</span>T<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>T<span class='generics'>&gt;</span> seq<span class='parens'>)</span></div></a></li></ul></ul></div>
<div class="interface">
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="_0_Prelude_0" class="def">Prelude</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Prelude/Memoizing/Prelude.Memoize.cs#L7" class="link">Source</a>
<a href="#_0_Prelude_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Func<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_memo_1" class="def">memo</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> func<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Prelude/Memoizing/Prelude.Memoize.cs#L14" class="link">Source</a>
<a href="#Prelude_0_memo_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Returns a Func<A> that wraps func.  The first
call to the resulting Func<A> will cache the result.
Subsequent calls return the cached item.</p>
</div>
<div></div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<a id="Prelude_0_memo_2" class="def">memo</a>
<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>B<span class='generics'>&gt;</span> func<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Prelude/Memoizing/Prelude.Memoize.cs#L49" class="link">Source</a>
<a href="#Prelude_0_memo_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> A : notnull</span></div></div></p>
<div class="doc"><div><p>Returns a <code>Func&lt;A, B&gt;</code> that wraps func.  Each time the resulting
<code>Func&lt;A, B&gt;</code> is called with a new value, its result is memoized (cached).
Subsequent calls use the memoized value.</p>
<p>Remarks:
Thread-safe and memory-leak safe.</p>
</div>
<div></div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Func<span class='generics'>&lt;</span>T<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_memoUnsafe_2" class="def">memoUnsafe</a>
<span class='generics'>&lt;</span>T<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>T<span class='comma'>, </span>R<span class='generics'>&gt;</span> func<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Prelude/Memoizing/Prelude.Memoize.cs#L84" class="link">Source</a>
<a href="#Prelude_0_memoUnsafe_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> T : notnull</span></div></div></p>
<div class="doc"><div><p>Returns a Func&lt;T,R&gt; that wraps func.  Each time the resulting
Func&lt;T,R&gt; is called with a new value, its result is memoized (cached).
Subsequent calls use the memoized value.</p>
<p>Remarks:
No mechanism for freeing cached values and therefore can cause a
memory leak when holding onto the Func&lt;T,R&gt; reference.
Uses a ConcurrentDictionary for the cache and is thread-safe</p>
</div>
<div></div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Seq<span class='generics'>&lt;</span>T<span class='generics'>&gt;</span>
<a id="Prelude_0_memo_1" class="def">memo</a>
<span class='generics'>&lt;</span>T<span class='generics'>&gt;</span>
<span class='parens'>(</span>IEnumerable<span class='generics'>&lt;</span>T<span class='generics'>&gt;</span> seq<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Prelude/Memoizing/Prelude.Memoize.cs#L120" class="link">Source</a>
<a href="#Prelude_0_memo_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Enumerable memoization.  As an enumerable is enumerated each item is retained
in an internal list, so that future evalation of the enumerable isn't done.
Only items not seen before are evaluated.</p>
<p>This minimises one of the major problems with the IEnumerable / yield return
pattern by causing at-most-once evaluation of each item.</p>
<p>Use the IEnumerable extension method Memo for convenience.</p>
</div>
<div><p>Although this allows efficient lazy evaluation, it does come at a memory cost.
Each item is cached internally, so this method doesn't allow for evaluation of
infinite sequences.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">seq</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Enumerable to memoize</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>IEnumerable with caching properties</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="_0_MemoExtensions_0" class="def">MemoExtensions</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Prelude/Memoizing/Prelude.Memoize.cs#L191" class="link">Source</a>
<a href="#_0_MemoExtensions_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Func<span class='generics'>&lt;</span>T<span class='generics'>&gt;</span>
<a id="MemoExtensions_0_Memo_1" class="def">Memo</a>
<span class='generics'>&lt;</span>T<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Func<span class='generics'>&lt;</span>T<span class='generics'>&gt;</span> func<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Prelude/Memoizing/Prelude.Memoize.cs#L198" class="link">Source</a>
<a href="#MemoExtensions_0_Memo_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Returns a Func<T> that wraps func.  The first
call to the resulting Func<T> will cache the result.
Subsequent calls return the cached item.</p>
</div>
<div></div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Func<span class='generics'>&lt;</span>T<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<a id="MemoExtensions_0_Memo_2" class="def">Memo</a>
<span class='generics'>&lt;</span>T<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Func<span class='generics'>&lt;</span>T<span class='comma'>, </span>R<span class='generics'>&gt;</span> func<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Prelude/Memoizing/Prelude.Memoize.cs#L209" class="link">Source</a>
<a href="#MemoExtensions_0_Memo_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> T : notnull</span></div></div></p>
<div class="doc"><div><p>Returns a Func&lt;T,R&gt; that wraps func.  Each time the resulting
Func&lt;T,R&gt; is called with a new value, its result is memoized (cached).
Subsequent calls use the memoized value.</p>
<p>Remarks:
Thread-safe and memory-leak safe.</p>
</div>
<div></div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Func<span class='generics'>&lt;</span>T<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<a id="MemoExtensions_0_MemoUnsafe_2" class="def">MemoUnsafe</a>
<span class='generics'>&lt;</span>T<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>this Func<span class='generics'>&lt;</span>T<span class='comma'>, </span>R<span class='generics'>&gt;</span> func<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Prelude/Memoizing/Prelude.Memoize.cs#L222" class="link">Source</a>
<a href="#MemoExtensions_0_MemoUnsafe_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> T : notnull</span></div></div></p>
<div class="doc"><div><p>Returns a Func&lt;T,R&gt; that wraps func.  Each time the resulting
Func&lt;T,R&gt; is called with a new value, its result is memoized (cached).
Subsequent calls use the memoized value.</p>
<p>Remarks:
No mechanism for freeing cached values and therefore can cause a
memory leak when holding onto the Func&lt;T,R&gt; reference.
Uses a ConcurrentDictionary for the cache and is thread-safe</p>
</div>
<div></div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
IEnumerable<span class='generics'>&lt;</span>T<span class='generics'>&gt;</span>
<a id="MemoExtensions_0_Memo_1" class="def">Memo</a>
<span class='generics'>&lt;</span>T<span class='generics'>&gt;</span>
<span class='parens'>(</span>this IEnumerable<span class='generics'>&lt;</span>T<span class='generics'>&gt;</span> seq<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Prelude/Memoizing/Prelude.Memoize.cs#L242" class="link">Source</a>
<a href="#MemoExtensions_0_Memo_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Enumerable memoization.  As an enumerable is enumerated each item is retained
in an internal list, so that future evalation of the enumerable isn't done.
Only items not seen before are evaluated.</p>
<p>This minimises one of the major problems with the IEnumerable / yield return
pattern by causing at-most-once evaluation of each item.</p>
<p>Use the IEnumerable extension method Memo for convenience.</p>
</div>
<div><p>Although this allows efficient lazy evaluation, it does come at a memory cost.
Each item is cached internally, so this method doesn't allow for evaluation of
infinite sequences.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">seq</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Enumerable to memoize</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>IEnumerable with caching properties</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div></div></div></body></html>