<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>LanguageExt.Core\Concurrency</title>
<link href="style.css" rel="stylesheet" type="text/css"/></head>
<body class="js-enabled"><div id="package-header"><ul class="links" id="page-menu"><li><a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency" class="link">Source</a></li>
<li><a href="../index.html" class="link">Contents</a></li>
<li><a href="../../index.html" class="link">Index</a></li></ul>
<p class="caption">LanguageExt.Core</p></div>
<div id="content"><div id="module-header"><p class="caption"><a href="../index.html" class="link">LanguageExt.Core</a>
<span> â–º </span>
<a href="index.html" class="link">Concurrency</a></p></div>
<div class="doc noleftpad"><p>We prefer to work with immutable types in functional-programming.  However, it's not always possible, and sometimes we
need some shared mutable state.  With the immutable types in this library you'd need to protect the updates with locks:</p>
<pre><code>// Some global
static HashSet&lt;int&gt; set = HashSet(1, 2, 3);
static object sync = new();

lock(sync)
{
    set = set.Add(4);
}
</code></pre>
<p>This in unsatisfactory, and so this module is all about lock-free atomic operations.  <code>Atom</code> allows you to protect any
value.  <code>AtomHashMap</code> and <code>AtomSeq</code> are <code>HashMap</code> and <code>Seq</code> wrapped up into a lock-free mutable structure.  Snapshots
of those are free!  The above code can be written:</p>
<pre><code>static AtomHashSet&lt;int&gt; set = AtomHashSet(1, 2, 3);
set.Add(4);
</code></pre>
<p>Finally, there's the Software Transactional Memory (STM) system.  Which allows for transactional changes to multiple
<code>Ref</code> values.  <code>Ref</code> just wrap up access to a value, and allows the state changes to be tracked by the <code>STM</code>.</p>
<p>See the <a href="https://github.com/louthy/language-ext/wiki/Concurrency">Concurrency</a> section of the wiki for more info.</p>
</div>
<div id="table-of-contents"><p class="caption">Contents</p>
<ul><li><a href="#LanguageExt_0_LastWriteWins_1" class="link"><div class="nowrap">LastWriteWins
<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span></div></a></li>
<ul><li><a href="#LastWriteWins_1_Resolve_0" class="link"><div class="nowrap">Resolve

<span class='parens'>(</span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Current<span class='comma'>, </span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Proposed<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_FirstWriteWins_1" class="link"><div class="nowrap">FirstWriteWins
<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span></div></a></li>
<ul><li><a href="#FirstWriteWins_1_Resolve_0" class="link"><div class="nowrap">Resolve

<span class='parens'>(</span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Current<span class='comma'>, </span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Proposed<span class='parens'>)</span></div></a></li></ul>
<li><a href="#LanguageExt_0_Conflict_1" class="link"><div class="nowrap">Conflict
<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span></div></a></li>
<ul></ul>
<li><a href="#LanguageExt_0_Prelude_0" class="link"><div class="nowrap">Prelude
</div></a></li>
<ul><li><a href="#Prelude_0_Ref_1" class="link"><div class="nowrap">Ref
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>A value<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>bool<span class='generics'>&gt;</span> validator = null<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_1" class="link"><div class="nowrap">atomic
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_1" class="link"><div class="nowrap">atomic
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_2" class="link"><div class="nowrap">atomic
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_1" class="link"><div class="nowrap">atomic
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_2" class="link"><div class="nowrap">atomic
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_1" class="link"><div class="nowrap">atomic
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_0" class="link"><div class="nowrap">atomic

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_1" class="link"><div class="nowrap">atomic
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_0" class="link"><div class="nowrap">atomic

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_0" class="link"><div class="nowrap">atomic

<span class='parens'>(</span>Action op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_1" class="link"><div class="nowrap">snapshot
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_1" class="link"><div class="nowrap">snapshot
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_2" class="link"><div class="nowrap">snapshot
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_1" class="link"><div class="nowrap">snapshot
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_2" class="link"><div class="nowrap">snapshot
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_1" class="link"><div class="nowrap">snapshot
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_0" class="link"><div class="nowrap">snapshot

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_1" class="link"><div class="nowrap">snapshot
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_0" class="link"><div class="nowrap">snapshot

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_0" class="link"><div class="nowrap">snapshot

<span class='parens'>(</span>Action op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_1" class="link"><div class="nowrap">serial
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_1" class="link"><div class="nowrap">serial
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_2" class="link"><div class="nowrap">serial
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_1" class="link"><div class="nowrap">serial
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_2" class="link"><div class="nowrap">serial
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_1" class="link"><div class="nowrap">serial
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_0" class="link"><div class="nowrap">serial

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_1" class="link"><div class="nowrap">serial
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_0" class="link"><div class="nowrap">serial

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_0" class="link"><div class="nowrap">serial

<span class='parens'>(</span>Action op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_1" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAsync_1" class="link"><div class="nowrap">swapAsync
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_1" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_1" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_2" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_2" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_2" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>A<span class='comma'>, </span>X<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAsync_2" class="link"><div class="nowrap">swapAsync
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_2" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_2" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_3" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_3" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_3" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>A<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAsync_3" class="link"><div class="nowrap">swapAsync
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_3" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_3" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_4" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_4" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_commute_1" class="link"><div class="nowrap">commute
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_commute_2" class="link"><div class="nowrap">commute
<span class='generics'>&lt;</span>A<span class='comma'>, </span>X<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_commute_3" class="link"><div class="nowrap">commute
<span class='generics'>&lt;</span>A<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_Atom_1" class="link"><div class="nowrap">Atom
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>A value<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_Atom_1" class="link"><div class="nowrap">Atom
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>A value<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>bool<span class='generics'>&gt;</span> validator<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_Atom_2" class="link"><div class="nowrap">Atom
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>M metadata<span class='comma'>, </span>A value<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_Atom_2" class="link"><div class="nowrap">Atom
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>M metadata<span class='comma'>, </span>A value<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>bool<span class='generics'>&gt;</span> validator<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_1" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_1" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_2" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAsync_1" class="link"><div class="nowrap">swapAsync
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_1" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_1" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_2" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_2" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_2" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_3" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAsync_2" class="link"><div class="nowrap">swapAsync
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_2" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_2" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_3" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_3" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_3" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_4" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAsync_3" class="link"><div class="nowrap">swapAsync
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_3" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_3" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_4" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_2" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_2" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_3" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAsync_2" class="link"><div class="nowrap">swapAsync
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_2" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_2" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_3" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_3" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_3" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_4" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAsync_3" class="link"><div class="nowrap">swapAsync
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_3" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_3" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_4" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_4" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_4" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapEff_5" class="link"><div class="nowrap">swapEff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAsync_4" class="link"><div class="nowrap">swapAsync
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_4" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>M<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_4" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>X<span class='comma'>, </span>M<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swapAff_5" class="link"><div class="nowrap">swapAff
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li></ul></ul></div>
<div class="interface"><H1>Sub modules</H1>
<table><tbody><tr><td class="src clearfix"><span class="inst-left"><a href="Atom\index.html" class="link">Atom</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="AtomHashMap\index.html" class="link">AtomHashMap</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="AtomSeq\index.html" class="link">AtomSeq</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="STM\index.html" class="link">STM</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="Task\index.html" class="link">Task</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="ValueTask\index.html" class="link">ValueTask</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="VectorClock\index.html" class="link">VectorClock</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="VersionHashMap\index.html" class="link">VersionHashMap</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="VersionVector\index.html" class="link">VersionVector</a></span></td></tr></tbody></table>
<div class="top"><p class="src"><span class="keyword">struct</span>
<a id="LanguageExt_0_LastWriteWins_1" class="def">LastWriteWins</a>
<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Conflict.cs#L14" class="link">Source</a>
<a href="#LanguageExt_0_LastWriteWins_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Last-write-wins conflict resolver</p>
</div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
(long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value)
<a id="LastWriteWins_1_Resolve_0" class="def">Resolve</a>

<span class='parens'>(</span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Current<span class='comma'>, </span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Proposed<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Conflict.cs#L16" class="link">Source</a>
<a href="#LastWriteWins_1_Resolve_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">struct</span>
<a id="LanguageExt_0_FirstWriteWins_1" class="def">FirstWriteWins</a>
<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Conflict.cs#L25" class="link">Source</a>
<a href="#LanguageExt_0_FirstWriteWins_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>First-write-wins conflict resolver</p>
</div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
(long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value)
<a id="FirstWriteWins_1_Resolve_0" class="def">Resolve</a>

<span class='parens'>(</span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Current<span class='comma'>, </span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Proposed<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Conflict.cs#L27" class="link">Source</a>
<a href="#FirstWriteWins_1_Resolve_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">interface</span>
<a id="LanguageExt_0_Conflict_1" class="def">Conflict</a>
<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Conflict.cs#L6" class="link">Source</a>
<a href="#LanguageExt_0_Conflict_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Trait that defines how to deal with a conflict between two values</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">V</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Value type</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="LanguageExt_0_Prelude_0" class="def">Prelude</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L7" class="link">Source</a>
<a href="#LanguageExt_0_Prelude_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_Ref_1" class="def">Ref</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>A value<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>bool<span class='generics'>&gt;</span> validator = null<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L66" class="link">Source</a>
<a href="#Prelude_0_Ref_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Generates a new reference that can be used within a <code>sync</code> transaction</p>
<p><code>Refs</code> ensure safe shared use of mutable storage locations via a software transactional
memory (STM) system. <code>Refs</code> are bound to a single storage location for their lifetime,
and only allow mutation of that location to occur within a transaction.</p>
</div>
<div><p>Transactions (within a <code>sync</code>) should be easy to understand if youâ€™ve ever used database
transactions - they ensure that all actions on Refs are atomic, consistent, and isolated.</p>
<ul>
<li class='markdown-bullet'>Atomic - means that every change to Refs made within a transaction occurs or none do.</li>
<li class='markdown-bullet'>Consistent - means that each new value can be checked with a validator function before allowing
the transaction to commit.</li>
<li class='markdown-bullet'>Isolated - means that no transaction sees the effects of any other transaction while it is
running.</li>
</ul>
<p>Another feature common to STMs is that, should a transaction have a conflict while running,
it is automatically retried.  The language-ext STM uses multiversion concurrency control for
snapshot and serialisable isolation.</p>
<p>In practice, this means:</p>
<p>All reads of Refs will see a consistent snapshot of the 'Ref world' as of the starting point
of the transaction (its 'read point'). The transaction will see any changes it has made.
This is called the in-transaction-value.</p>
<p>All changes made to Refs during a transaction will appear to occur at a single point in the
'Ref world' timeline (its 'write point').</p>
<p>No changes will have been made by any other transactions to any Refs that have been modified
by this transaction.</p>
<p>Readers will never block writers, or other readers.</p>
<p>Writers will never block readers.</p>
<p>I/O and other activities with side-effects should be avoided in transactions, since transactions
will be retried.</p>
<p>If a constraint on the validity of a value of a Ref that is being changed depends upon the
simultaneous value of a Ref that is not being changed, that second Ref can be protected from
modification by running the <code>sync</code> transaction with Isolation.Serialisable.</p>
<p>The language-ext STM is designed to work with the persistent collections (<code>Map</code>, <code>HashMap</code>,
<code>Seq</code>, <code>Lst</code>, <code>Set, </code>HashSet` etc.), and it is strongly recommended that you use the language-ext
collections as the values of your Refs. Since all work done in an STM transaction is speculative,
it is imperative that there be a low cost to making copies and modifications. Persistent collections
have free copies (just use the original, it canâ€™t be changed), and 'modifications' share structure
efficiently. In any case:</p>
<p>The values placed in Refs must be, or be considered, <strong>immutable</strong> Otherwise, Clojure canâ€™t help you.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">value</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Initial value of the ref</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">validator</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Validator that is called on the ref value just
before any transaction is committed (within a <code>sync</code>)</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
R
<a id="Prelude_0_atomic_1" class="def">atomic</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L102" class="link">Source</a>
<a href="#Prelude_0_atomic_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_atomic_1" class="def">atomic</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L138" class="link">Source</a>
<a href="#Prelude_0_atomic_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_atomic_2" class="def">atomic</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L174" class="link">Source</a>
<a href="#Prelude_0_atomic_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_atomic_1" class="def">atomic</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L210" class="link">Source</a>
<a href="#Prelude_0_atomic_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_atomic_2" class="def">atomic</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L246" class="link">Source</a>
<a href="#Prelude_0_atomic_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_atomic_1" class="def">atomic</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L282" class="link">Source</a>
<a href="#Prelude_0_atomic_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Unit<span class='generics'>&gt;</span>
<a id="Prelude_0_atomic_0" class="def">atomic</a>

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L318" class="link">Source</a>
<a href="#Prelude_0_atomic_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_atomic_1" class="def">atomic</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L354" class="link">Source</a>
<a href="#Prelude_0_atomic_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>Unit<span class='generics'>&gt;</span>
<a id="Prelude_0_atomic_0" class="def">atomic</a>

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L390" class="link">Source</a>
<a href="#Prelude_0_atomic_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Unit
<a id="Prelude_0_atomic_0" class="def">atomic</a>

<span class='parens'>(</span>Action op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L426" class="link">Source</a>
<a href="#Prelude_0_atomic_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
R
<a id="Prelude_0_snapshot_1" class="def">snapshot</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L440" class="link">Source</a>
<a href="#Prelude_0_snapshot_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_snapshot_1" class="def">snapshot</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L453" class="link">Source</a>
<a href="#Prelude_0_snapshot_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_snapshot_2" class="def">snapshot</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L466" class="link">Source</a>
<a href="#Prelude_0_snapshot_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_snapshot_1" class="def">snapshot</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L479" class="link">Source</a>
<a href="#Prelude_0_snapshot_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_snapshot_2" class="def">snapshot</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L493" class="link">Source</a>
<a href="#Prelude_0_snapshot_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_snapshot_1" class="def">snapshot</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L506" class="link">Source</a>
<a href="#Prelude_0_snapshot_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Unit<span class='generics'>&gt;</span>
<a id="Prelude_0_snapshot_0" class="def">snapshot</a>

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L519" class="link">Source</a>
<a href="#Prelude_0_snapshot_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_snapshot_1" class="def">snapshot</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L532" class="link">Source</a>
<a href="#Prelude_0_snapshot_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>Unit<span class='generics'>&gt;</span>
<a id="Prelude_0_snapshot_0" class="def">snapshot</a>

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L545" class="link">Source</a>
<a href="#Prelude_0_snapshot_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Unit
<a id="Prelude_0_snapshot_0" class="def">snapshot</a>

<span class='parens'>(</span>Action op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L558" class="link">Source</a>
<a href="#Prelude_0_snapshot_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside of the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
R
<a id="Prelude_0_serial_1" class="def">serial</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L590" class="link">Source</a>
<a href="#Prelude_0_serial_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_serial_1" class="def">serial</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L621" class="link">Source</a>
<a href="#Prelude_0_serial_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_serial_2" class="def">serial</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L652" class="link">Source</a>
<a href="#Prelude_0_serial_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_serial_1" class="def">serial</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L683" class="link">Source</a>
<a href="#Prelude_0_serial_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_serial_2" class="def">serial</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L714" class="link">Source</a>
<a href="#Prelude_0_serial_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_serial_1" class="def">serial</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L745" class="link">Source</a>
<a href="#Prelude_0_serial_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Unit<span class='generics'>&gt;</span>
<a id="Prelude_0_serial_0" class="def">serial</a>

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>ValueTask<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L776" class="link">Source</a>
<a href="#Prelude_0_serial_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<a id="Prelude_0_serial_1" class="def">serial</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span><span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L807" class="link">Source</a>
<a href="#Prelude_0_serial_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Task<span class='generics'>&lt;</span>Unit<span class='generics'>&gt;</span>
<a id="Prelude_0_serial_0" class="def">serial</a>

<span class='parens'>(</span>Func<span class='generics'>&lt;</span>Task<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L838" class="link">Source</a>
<a href="#Prelude_0_serial_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Unit
<a id="Prelude_0_serial_0" class="def">serial</a>

<span class='parens'>(</span>Action op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L869" class="link">Source</a>
<a href="#Prelude_0_serial_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside of the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does write to the values that are used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the most strict form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would not cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
A
<a id="Prelude_0_swap_1" class="def">swap</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L881" class="link">Source</a>
<a href="#Prelude_0_swap_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAsync_1" class="def">swapAsync</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L892" class="link">Source</a>
<a href="#Prelude_0_swapAsync_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_1" class="def">swapAff</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L903" class="link">Source</a>
<a href="#Prelude_0_swapAff_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_1" class="def">swapEff</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L914" class="link">Source</a>
<a href="#Prelude_0_swapEff_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_2" class="def">swapAff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L925" class="link">Source</a>
<a href="#Prelude_0_swapAff_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_2" class="def">swapEff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L936" class="link">Source</a>
<a href="#Prelude_0_swapEff_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
A
<a id="Prelude_0_swap_2" class="def">swap</a>
<span class='generics'>&lt;</span>A<span class='comma'>, </span>X<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L947" class="link">Source</a>
<a href="#Prelude_0_swap_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAsync_2" class="def">swapAsync</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L958" class="link">Source</a>
<a href="#Prelude_0_swapAsync_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_2" class="def">swapAff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L969" class="link">Source</a>
<a href="#Prelude_0_swapAff_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_2" class="def">swapEff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L980" class="link">Source</a>
<a href="#Prelude_0_swapEff_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_3" class="def">swapAff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L991" class="link">Source</a>
<a href="#Prelude_0_swapAff_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_3" class="def">swapEff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1002" class="link">Source</a>
<a href="#Prelude_0_swapEff_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
A
<a id="Prelude_0_swap_3" class="def">swap</a>
<span class='generics'>&lt;</span>A<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1013" class="link">Source</a>
<a href="#Prelude_0_swap_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAsync_3" class="def">swapAsync</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1024" class="link">Source</a>
<a href="#Prelude_0_swapAsync_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_3" class="def">swapAff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1035" class="link">Source</a>
<a href="#Prelude_0_swapAff_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_3" class="def">swapEff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1046" class="link">Source</a>
<a href="#Prelude_0_swapEff_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_4" class="def">swapAff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1057" class="link">Source</a>
<a href="#Prelude_0_swapAff_4" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_4" class="def">swapEff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1068" class="link">Source</a>
<a href="#Prelude_0_swapEff_4" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
A
<a id="Prelude_0_commute_1" class="def">commute</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1090" class="link">Source</a>
<a href="#Prelude_0_commute_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Must be called in a transaction. Sets the in-transaction-value of
ref to:</p>
<pre><code>`f(in-transaction-value-of-ref)`
</code></pre>
<p>and returns the in-transaction-value when complete.</p>
<p>At the commit point of the transaction, <code>f</code> is run <em>AGAIN</em> with the
most recently committed value:</p>
<pre><code>`f(most-recently-committed-value-of-ref)`
</code></pre>
<p>Thus <code>f</code> should be commutative, or, failing that, you must accept
last-one-in-wins behavior.</p>
<p>Commute allows for more concurrency than just setting the Ref's value</p>
</div>
<div></div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
A
<a id="Prelude_0_commute_2" class="def">commute</a>
<span class='generics'>&lt;</span>A<span class='comma'>, </span>X<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1112" class="link">Source</a>
<a href="#Prelude_0_commute_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Must be called in a transaction. Sets the in-transaction-value of
ref to:</p>
<pre><code>`f(in-transaction-value-of-ref)`
</code></pre>
<p>and returns the in-transaction-value when complete.</p>
<p>At the commit point of the transaction, <code>f</code> is run <em>AGAIN</em> with the
most recently committed value:</p>
<pre><code>`f(most-recently-committed-value-of-ref)`
</code></pre>
<p>Thus <code>f</code> should be commutative, or, failing that, you must accept
last-one-in-wins behavior.</p>
<p>Commute allows for more concurrency than just setting the Ref's value</p>
</div>
<div></div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
A
<a id="Prelude_0_commute_3" class="def">commute</a>
<span class='generics'>&lt;</span>A<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1134" class="link">Source</a>
<a href="#Prelude_0_commute_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Must be called in a transaction. Sets the in-transaction-value of
ref to:</p>
<pre><code>`f(in-transaction-value-of-ref)`
</code></pre>
<p>and returns the in-transaction-value when complete.</p>
<p>At the commit point of the transaction, <code>f</code> is run <em>AGAIN</em> with the
most recently committed value:</p>
<pre><code>`f(most-recently-committed-value-of-ref)`
</code></pre>
<p>Thus <code>f</code> should be commutative, or, failing that, you must accept
last-one-in-wins behavior.</p>
<p>Commute allows for more concurrency than just setting the Ref's value</p>
</div>
<div></div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_Atom_1" class="def">Atom</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>A value<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1160" class="link">Source</a>
<a href="#Prelude_0_Atom_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atoms provide a way to manage shared, synchronous, independent state without
locks.</p>
</div>
<div><p>The intended use of atom is to hold one an immutable data structure. You change
the value by applying a function to the old value. This is done in an atomic
manner by <code>Swap</code>.</p>
<p>Internally, <code>Swap</code> reads the current value, applies the function to it, and
attempts to <code>CompareExchange</code> it in. Since another thread may have changed the
value in the intervening time, it may have to retry, and does so in a spin loop.</p>
<p>The net effect is that the value will always be the result of the application
of the supplied function to a current value, atomically. However, because the
function might be called multiple times, it must be free of side effects.</p>
<p>Atoms are an efficient way to represent some state that will never need to be
coordinated with any other, and for which you wish to make synchronous changes.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">value</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Initial value of the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The constructed Atom</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="Prelude_0_Atom_1" class="def">Atom</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>A value<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>bool<span class='generics'>&gt;</span> validator<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1193" class="link">Source</a>
<a href="#Prelude_0_Atom_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atoms provide a way to manage shared, synchronous, independent state without
locks.</p>
</div>
<div><p>The intended use of atom is to hold one an immutable data structure. You change
the value by applying a function to the old value. This is done in an atomic
manner by <code>Swap</code>.</p>
<p>Internally, <code>Swap</code> reads the current value, applies the function to it, and
attempts to <code>CompareExchange</code> it in. Since another thread may have changed the
value in the intervening time, it may have to retry, and does so in a spin loop.</p>
<p>The net effect is that the value will always be the result of the application
of the supplied function to a current value, atomically. However, because the
function might be called multiple times, it must be free of side effects.</p>
<p>Atoms are an efficient way to represent some state that will never need to be
coordinated with any other, and for which you wish to make synchronous changes.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">value</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Initial value of the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">validator</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to run on the value after each state change.</p>
<p>If the function returns false for any proposed new state, then the <code>swap</code>
function will return <code>false</code>, else it will return <code>true</code> on successful setting
of the atom's state</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The constructed Atom or None if the validation faled for the initial
<code>value</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_Atom_2" class="def">Atom</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>M metadata<span class='comma'>, </span>A value<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1220" class="link">Source</a>
<a href="#Prelude_0_Atom_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atoms provide a way to manage shared, synchronous, independent state without
locks.</p>
</div>
<div><p>The intended use of atom is to hold one an immutable data structure. You change
the value by applying a function to the old value. This is done in an atomic
manner by <code>Swap</code>.</p>
<p>Internally, <code>Swap</code> reads the current value, applies the function to it, and
attempts to <code>CompareExchange</code> it in. Since another thread may have changed the
value in the intervening time, it may have to retry, and does so in a spin loop.</p>
<p>The net effect is that the value will always be the result of the application
of the supplied function to a current value, atomically. However, because the
function might be called multiple times, it must be free of side effects.</p>
<p>Atoms are an efficient way to represent some state that will never need to be
coordinated with any other, and for which you wish to make synchronous changes.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">metadata</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Metadata to be passed to the validation function</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">value</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Initial value of the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The constructed Atom</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="Prelude_0_Atom_2" class="def">Atom</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>M metadata<span class='comma'>, </span>A value<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>bool<span class='generics'>&gt;</span> validator<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1254" class="link">Source</a>
<a href="#Prelude_0_Atom_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atoms provide a way to manage shared, synchronous, independent state without
locks.</p>
</div>
<div><p>The intended use of atom is to hold one an immutable data structure. You change
the value by applying a function to the old value. This is done in an atomic
manner by <code>Swap</code>.</p>
<p>Internally, <code>Swap</code> reads the current value, applies the function to it, and
attempts to <code>CompareExchange</code> it in. Since another thread may have changed the
value in the intervening time, it may have to retry, and does so in a spin loop.</p>
<p>The net effect is that the value will always be the result of the application
of the supplied function to a current value, atomically. However, because the
function might be called multiple times, it must be free of side effects.</p>
<p>Atoms are an efficient way to represent some state that will never need to be
coordinated with any other, and for which you wish to make synchronous changes.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">metadata</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Metadata to be passed to the validation function</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">value</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Initial value of the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">validator</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to run on the value after each state change.</p>
<p>If the function returns false for any proposed new state, then the <code>swap</code>
function will return <code>false</code>, else it will return <code>true</code> on successful setting
of the atom's state</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The constructed Atom or None if the validation faled for the initial
<code>value</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swap_1" class="def">swap</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1266" class="link">Source</a>
<a href="#Prelude_0_swap_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_1" class="def">swapEff</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1278" class="link">Source</a>
<a href="#Prelude_0_swapEff_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_2" class="def">swapEff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1289" class="link">Source</a>
<a href="#Prelude_0_swapEff_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="Prelude_0_swapAsync_1" class="def">swapAsync</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1300" class="link">Source</a>
<a href="#Prelude_0_swapAsync_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_1" class="def">swapAff</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1311" class="link">Source</a>
<a href="#Prelude_0_swapAff_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_1" class="def">swapAff</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1322" class="link">Source</a>
<a href="#Prelude_0_swapAff_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_2" class="def">swapAff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1333" class="link">Source</a>
<a href="#Prelude_0_swapAff_2" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swap_2" class="def">swap</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1345" class="link">Source</a>
<a href="#Prelude_0_swap_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_2" class="def">swapEff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1357" class="link">Source</a>
<a href="#Prelude_0_swapEff_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_3" class="def">swapEff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1369" class="link">Source</a>
<a href="#Prelude_0_swapEff_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="Prelude_0_swapAsync_2" class="def">swapAsync</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1381" class="link">Source</a>
<a href="#Prelude_0_swapAsync_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_2" class="def">swapAff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1393" class="link">Source</a>
<a href="#Prelude_0_swapAff_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_2" class="def">swapAff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1405" class="link">Source</a>
<a href="#Prelude_0_swapAff_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_3" class="def">swapAff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1417" class="link">Source</a>
<a href="#Prelude_0_swapAff_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swap_3" class="def">swap</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1430" class="link">Source</a>
<a href="#Prelude_0_swap_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_3" class="def">swapEff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1443" class="link">Source</a>
<a href="#Prelude_0_swapEff_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_4" class="def">swapEff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1456" class="link">Source</a>
<a href="#Prelude_0_swapEff_4" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="Prelude_0_swapAsync_3" class="def">swapAsync</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1469" class="link">Source</a>
<a href="#Prelude_0_swapAsync_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_3" class="def">swapAff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1482" class="link">Source</a>
<a href="#Prelude_0_swapAff_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_3" class="def">swapAff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1495" class="link">Source</a>
<a href="#Prelude_0_swapAff_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_4" class="def">swapAff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1508" class="link">Source</a>
<a href="#Prelude_0_swapAff_4" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swap_2" class="def">swap</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1520" class="link">Source</a>
<a href="#Prelude_0_swap_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_2" class="def">swapEff</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1531" class="link">Source</a>
<a href="#Prelude_0_swapEff_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_3" class="def">swapEff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1542" class="link">Source</a>
<a href="#Prelude_0_swapEff_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="Prelude_0_swapAsync_2" class="def">swapAsync</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1553" class="link">Source</a>
<a href="#Prelude_0_swapAsync_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_2" class="def">swapAff</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1564" class="link">Source</a>
<a href="#Prelude_0_swapAff_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_2" class="def">swapAff</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1575" class="link">Source</a>
<a href="#Prelude_0_swapAff_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_3" class="def">swapAff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1586" class="link">Source</a>
<a href="#Prelude_0_swapAff_3" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swap_3" class="def">swap</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1598" class="link">Source</a>
<a href="#Prelude_0_swap_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_3" class="def">swapEff</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1610" class="link">Source</a>
<a href="#Prelude_0_swapEff_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_4" class="def">swapEff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1622" class="link">Source</a>
<a href="#Prelude_0_swapEff_4" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="Prelude_0_swapAsync_3" class="def">swapAsync</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1634" class="link">Source</a>
<a href="#Prelude_0_swapAsync_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_3" class="def">swapAff</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1646" class="link">Source</a>
<a href="#Prelude_0_swapAff_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_3" class="def">swapAff</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1658" class="link">Source</a>
<a href="#Prelude_0_swapAff_3" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_4" class="def">swapAff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1670" class="link">Source</a>
<a href="#Prelude_0_swapAff_4" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swap_4" class="def">swap</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1683" class="link">Source</a>
<a href="#Prelude_0_swap_4" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_4" class="def">swapEff</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1696" class="link">Source</a>
<a href="#Prelude_0_swapEff_4" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapEff_5" class="def">swapEff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Eff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1709" class="link">Source</a>
<a href="#Prelude_0_swapEff_5" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Eff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
ValueTask<span class='generics'>&lt;</span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="Prelude_0_swapAsync_4" class="def">swapAsync</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1722" class="link">Source</a>
<a href="#Prelude_0_swapAsync_4" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Option in a Some state, with the result of the invocation of <code>f</code>, if the swap succeeded
and its validation passed. None otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_4" class="def">swapAff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>M<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1735" class="link">Source</a>
<a href="#Prelude_0_swapAff_4" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_4" class="def">swapAff</a>
<span class='generics'>&lt;</span>X<span class='comma'>, </span>M<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>ValueTask<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1748" class="link">Source</a>
<a href="#Prelude_0_swapAff_4" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_swapAff_5" class="def">swapAff</a>
<span class='generics'>&lt;</span>RT<span class='comma'>, </span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>X x<span class='comma'>, </span>Y y<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>X<span class='comma'>, </span>Y<span class='comma'>, </span>A<span class='comma'>, </span>Aff<span class='generics'>&lt;</span>RT<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude_Concurrency.cs#L1761" class="link">Source</a>
<a href="#Prelude_0_swapAff_5" class="selflink">#</a>
<div class="constraints"><div class="constraint"><span class="keyword">where</span>
<span> RT : struct, HasCancel&lt;RT&gt;</span></div></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side-effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">x</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">y</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Additional value to pass to <code>f</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>Aff in a Succ state, with the result of the invocation of <code>f</code>, if the swap succeeded and its
validation passed. Failure state otherwise</p>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div></div></div></body></html>