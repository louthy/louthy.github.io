<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>LanguageExt.Core\Concurrency</title>
<link href="style.css" rel="stylesheet" type="text/css"/></head>
<body class="js-enabled"><div id="package-header"><ul class="links" id="page-menu"><li><a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency" class="link">Source</a></li>
<li><a href="../index.html" class="link">Contents</a></li>
<li><a href="../../index.html" class="link">Index</a></li></ul>
<p class="caption">LanguageExt.Core</p></div>
<div id="content"><div id="module-header"><p class="caption"><a href="../index.html" class="link">LanguageExt.Core</a>
<span> ► </span>
<a href="index.html" class="link">Concurrency</a></p></div>
<p>We prefer to work with immutable types in functional-programming.  However, it's not always possible, and sometimes we
need some shared mutable state.  With the immutable types in this library you'd need to protect the updates with locks:</p>
<pre><code>// Some global
static HashSet&lt;int&gt; set = HashSet(1, 2, 3);
static object sync = new();

lock(sync)
{
    set = set.Add(4);
}
</code></pre>
<p>This in unsatisfactory, and so this module is all about lock-free atomic operations.  <code>Atom</code> allows you to protect any
value.  <code>AtomHashMap</code> and <code>AtomSeq</code> are <code>HashMap</code> and <code>Seq</code> wrapped up into a lock-free mutable structure.  Snapshots
of those are free!  The above code can be written:</p>
<pre><code>static AtomHashSet&lt;int&gt; set = AtomHashSet(1, 2, 3);
set.Add(4);
</code></pre>
<p>Finally, there's the Software Transactional Memory (STM) system.  Which allows for transactional changes to multiple
<code>Ref</code> values.  <code>Ref</code> just wrap up access to a value, and allows the state changes to be tracked by the <code>STM</code>.</p>
<p>See the <a href="https://github.com/louthy/language-ext/wiki/Concurrency">concurrency section</a> of the wiki for more info.</p>

<div id="table-of-contents"><p class="caption">Contents</p>
<ul><li><a href="#_0_LastWriteWins_1" class="link"><div class="nowrap">LastWriteWins
<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span></div></a></li>
<ul><li><a href="#LastWriteWins_1_Resolve_0" class="link"><div class="nowrap">Resolve

<span class='parens'>(</span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Current,
                                                            <span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Proposed<span class='parens'>)</span></div></a></li></ul>
<li><a href="#_0_FirstWriteWins_1" class="link"><div class="nowrap">FirstWriteWins
<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span></div></a></li>
<ul><li><a href="#FirstWriteWins_1_Resolve_0" class="link"><div class="nowrap">Resolve

<span class='parens'>(</span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Current,
                                                            <span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Proposed<span class='parens'>)</span></div></a></li></ul>
<li><a href="#_0_Conflict_1" class="link"><div class="nowrap">Conflict
<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span></div></a></li>
<ul><li><a href="#Conflict_1_Resolve_0" class="link"><div class="nowrap">Resolve

<span class='parens'>(</span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Current,
                                                                     <span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Proposed<span class='parens'>)</span></div></a></li></ul>
<li><a href="#_0_Prelude_0" class="link"><div class="nowrap">Prelude
</div></a></li>
<ul><li><a href="#Prelude_0_Ref_1" class="link"><div class="nowrap">Ref
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>A value<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>bool<span class='generics'>&gt;</span>? validator = null<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_1" class="link"><div class="nowrap">atomic
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_atomic_0" class="link"><div class="nowrap">atomic

<span class='parens'>(</span>Action op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_1" class="link"><div class="nowrap">snapshot
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_snapshot_0" class="link"><div class="nowrap">snapshot

<span class='parens'>(</span>Action op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_1" class="link"><div class="nowrap">serial
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_serial_0" class="link"><div class="nowrap">serial

<span class='parens'>(</span>Action op<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_1" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_commute_1" class="link"><div class="nowrap">commute
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_Atom_1" class="link"><div class="nowrap">Atom
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>A value<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_Atom_1" class="link"><div class="nowrap">Atom
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>A value<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>bool<span class='generics'>&gt;</span> validator<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_Atom_2" class="link"><div class="nowrap">Atom
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>M metadata<span class='comma'>, </span>A value<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_Atom_2" class="link"><div class="nowrap">Atom
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>M metadata<span class='comma'>, </span>A value<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>bool<span class='generics'>&gt;</span> validator<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_1" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_1" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_2" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li>
<li><a href="#Prelude_0_swap_2" class="link"><div class="nowrap">swap
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span></div></a></li></ul></ul></div>
<div class="interface"><H1>Sub modules</H1>
<table><tbody><tr><td class="src clearfix"><span class="inst-left"><a href="Atom\index.html" class="link">Atom</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="AtomHashMap\index.html" class="link">AtomHashMap</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="AtomQue\index.html" class="link">AtomQue</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="AtomSeq\index.html" class="link">AtomSeq</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="STM\index.html" class="link">STM</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="Task\index.html" class="link">Task</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="ValueTask\index.html" class="link">ValueTask</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="VectorClock\index.html" class="link">VectorClock</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="VersionHashMap\index.html" class="link">VersionHashMap</a></span></td></tr>
<tr><td class="src clearfix"><span class="inst-left"><a href="VersionVector\index.html" class="link">VersionVector</a></span></td></tr></tbody></table>
<div class="top"><p class="src"><span class="keyword">struct</span>
<a id="_0_LastWriteWins_1" class="def">LastWriteWins</a>
<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Conflict.cs#L16" class="link">Source</a>
<a href="#_0_LastWriteWins_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Last-write-wins conflict resolver</p>
</div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
(long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value)
<a id="LastWriteWins_1_Resolve_0" class="def">Resolve</a>

<span class='parens'>(</span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Current,
                                                            <span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Proposed<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Conflict.cs#L18" class="link">Source</a>
<a href="#LastWriteWins_1_Resolve_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">struct</span>
<a id="_0_FirstWriteWins_1" class="def">FirstWriteWins</a>
<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Conflict.cs#L28" class="link">Source</a>
<a href="#_0_FirstWriteWins_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>First-write-wins conflict resolver</p>
</div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
(long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value)
<a id="FirstWriteWins_1_Resolve_0" class="def">Resolve</a>

<span class='parens'>(</span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Current,
                                                            <span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Proposed<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Conflict.cs#L30" class="link">Source</a>
<a href="#FirstWriteWins_1_Resolve_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">interface</span>
<a id="_0_Conflict_1" class="def">Conflict</a>
<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Conflict.cs#L7" class="link">Source</a>
<a href="#_0_Conflict_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Trait that defines how to deal with a conflict between two values</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">type</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">V</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Value type</p>
</span></td></tr></tbody></table></div></div>
</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
(long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value)
<a id="Conflict_1_Resolve_0" class="def">Resolve</a>

<span class='parens'>(</span><span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Current,
                                                                     <span class='parens'>(</span>long TimeStamp<span class='comma'>, </span>Option<span class='generics'>&lt;</span>V<span class='generics'>&gt;</span> Value<span class='parens'>)</span> Proposed<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Conflict.cs#L9" class="link">Source</a>
<a href="#Conflict_1_Resolve_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>












</div></div>




</div>
<div class="top"><p class="src"><span class="keyword">class</span>
<a id="_0_Prelude_0" class="def">Prelude</a>

<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude.Concurrency.cs#L6" class="link">Source</a>
<a href="#_0_Prelude_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div></div>

</div>







<div class="subs methods"><p class="caption">Methods</p>
<div class="top"><p class="src"><span class="keyword">method</span>
Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_Ref_1" class="def">Ref</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>A value<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>bool<span class='generics'>&gt;</span>? validator = null<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude.Concurrency.cs#L68" class="link">Source</a>
<a href="#Prelude_0_Ref_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Generates a new reference that can be used within a <code>sync</code> transaction</p>
<p><code>Refs</code> ensure safe shared use of mutable storage locations via a software transactional
memory (STM) system. <code>Refs</code> are bound to a single storage location for their lifetime,
and only allow mutation of that location to occur within a transaction.</p>
</div>
<div><p>Transactions (within a <code>sync(() =&gt; ...)</code>) should be easy to understand if you’ve ever used database
transactions - they ensure that all actions on Refs are atomic, consistent, and isolated.</p>
<ul>
<li class='markdown-bullet'><strong>Atomic</strong> - means that every change to Refs made within a transaction occurs or none do.</li>
<li class='markdown-bullet'><strong>Consistent</strong> - means that each new value can be checked with a validator function before allowing
the transaction to commit.</li>
<li class='markdown-bullet'><strong>Isolated</strong> - means that no transaction sees the effects of any other transaction while it is
running.</li>
</ul>
<p>Another feature common to STMs is that, should a transaction have a conflict while running,
it is automatically retried.  The language-ext STM uses multi-version concurrency control for
snapshot and serialisable isolation.</p>
<p>In practice, this means:</p>
<p>All reads of Refs will see a consistent snapshot of the <em>Ref world</em> as of the starting point
of the transaction (its 'read point'). The transaction will see any changes it has made.
This is called the in-transaction-value.</p>
<p>All changes made to Refs during a transaction will appear to occur at a single point in the
<em>Ref world</em> timeline (its 'write point').</p>
<p>No changes will have been made by any other transactions to any Refs that have been modified
by this transaction.</p>
<ul>
<li class='markdown-bullet'><p>Readers will never block writers, or other readers.</p>
</li>
<li class='markdown-bullet'><p>Writers will never block readers.</p>
</li>
</ul>
<p>I/O and other activities with side-effects should be avoided in transactions, since transactions
will be retried.</p>
<p>If a constraint on the validity of a value of a Ref that is being changed depends upon the
simultaneous value of a Ref that is not being changed, that second Ref can be protected from
modification by running the <code>sync</code> transaction with <code>Isolation.Serialisable</code>.</p>
<p>The language-ext STM is designed to work with the persistent collections (<code>Map</code>, <code>HashMap</code>,
<code>Seq</code>, <code>Lst</code>, <code>Set, </code>HashSet` etc.), and it is strongly recommended that you use the language-ext
collections as the values of your Refs. Since all work done in an STM transaction is speculative,
it is imperative that there be a low cost to making copies and modifications. Persistent collections
have free copies (just use the original, it can’t be changed), and 'modifications' share structure
efficiently. In any case:</p>
<p>The values placed in Refs must be, or be considered, <strong>immutable</strong>. Otherwise, this library can’t help you.</p>

<p>See the <a href="https://github.com/louthy/language-ext/wiki/Concurrency">concurrency section</a> of the wiki for more info.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">value</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Initial value of the ref</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">validator</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Validator that is called on the ref value just
before any transaction is committed (within a <code>sync</code>)</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
R
<a id="Prelude_0_atomic_1" class="def">atomic</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude.Concurrency.cs#L100" class="link">Source</a>
<a href="#Prelude_0_atomic_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div></div>
<div><p>Snapshot isolation requires that nothing outside the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does read from or written to the values used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the strictest form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would <em>not</em> cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Unit
<a id="Prelude_0_atomic_0" class="def">atomic</a>

<span class='parens'>(</span>Action op<span class='comma'>, </span>Isolation isolation = Isolation.Snapshot<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude.Concurrency.cs#L136" class="link">Source</a>
<a href="#Prelude_0_atomic_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>

<p>Serialisable isolation requires that nothing outside the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does read from or written to the values used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the strictest form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would <em>not</em> cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
R
<a id="Prelude_0_snapshot_1" class="def">snapshot</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude.Concurrency.cs#L149" class="link">Source</a>
<a href="#Prelude_0_snapshot_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Unit
<a id="Prelude_0_snapshot_0" class="def">snapshot</a>

<span class='parens'>(</span>Action op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude.Concurrency.cs#L162" class="link">Source</a>
<a href="#Prelude_0_snapshot_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Snapshot isolation requires that nothing outside the transaction has written to any of the values that are
<em>written-to within the transaction</em>.  If anything does write to the values used within the transaction, then
the transaction is rolled back and retried (using the latest 'world' state).</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
R
<a id="Prelude_0_serial_1" class="def">serial</a>
<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span>
<span class='parens'>(</span>Func<span class='generics'>&lt;</span>R<span class='generics'>&gt;</span> op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude.Concurrency.cs#L193" class="link">Source</a>
<a href="#Prelude_0_serial_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does read from or written to the values used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the strictest form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would <em>not</em> cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Unit
<a id="Prelude_0_serial_0" class="def">serial</a>

<span class='parens'>(</span>Action op<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude.Concurrency.cs#L224" class="link">Source</a>
<a href="#Prelude_0_serial_0" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Run the op within a new transaction
If a transaction is already running, then this becomes part of the parent transaction</p>
</div>
<div><p>Serialisable isolation requires that nothing outside the transaction has written to any of the values that
are <em>read-from or written-to within the transaction</em>.  If anything does read from or written to the values used
within the transaction, then it is rolled back and retried (using the latest 'world' state).</p>
<p>It is the strictest form of isolation, and the most likely to conflict; but protects against cross read/write
inconsistencies.  For example, if you have:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

snapshot(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>Then something writing to <code>y</code> mid-way through the transaction would <em>not</em> cause the transaction to fail.
Because <code>y</code> was only read-from, not written to.  However, this:</p>
<pre><code>var x = Ref(1);
var y = Ref(2);

serial(() =&gt; x.Value = y.Value + 1);
</code></pre>
<p>... would fail if something wrote to <code>y</code>.</p>
</div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
A
<a id="Prelude_0_swap_1" class="def">swap</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude.Concurrency.cs#L235" class="link">Source</a>
<a href="#Prelude_0_swap_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Swap the old value for the new returned by <code>f</code>
Must be run within a <code>sync</code> transaction</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">r</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p><code>Ref</code> to process</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the <code>Ref</code></p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The value returned from <code>f</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
A
<a id="Prelude_0_commute_1" class="def">commute</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Ref<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> r<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude.Concurrency.cs#L257" class="link">Source</a>
<a href="#Prelude_0_commute_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Must be called in a transaction. Sets the in-transaction-value of
ref to:</p>
<pre><code>`f(in-transaction-value-of-ref)`
</code></pre>
<p>and returns the in-transaction-value when complete.</p>
<p>At the commit point of the transaction, <code>f</code> is run <em>AGAIN</em> with the
most recently committed value:</p>
<pre><code>`f(most-recently-committed-value-of-ref)`
</code></pre>
<p>Thus <code>f</code> should be commutative, or, failing that, you must accept
last-one-in-wins behavior.</p>
<p>Commute allows for more concurrency than just setting the Ref's value</p>
</div>
<div></div>

</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_Atom_1" class="def">Atom</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>A value<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude.Concurrency.cs#L283" class="link">Source</a>
<a href="#Prelude_0_Atom_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atoms provide a way to manage shared, synchronous, independent state without
locks.</p>
</div>
<div><p>The intended use of atom is to hold one an immutable data structure. You change
the value by applying a function to the old value. This is done in an atomic
manner by <code>Swap</code>.</p>
<p>Internally, <code>Swap</code> reads the current value, applies the function to it, and
attempts to <code>CompareExchange</code> it in. Since another thread may have changed the
value in the intervening time, it may have to retry, and does so in a spin loop.</p>
<p>The net effect is that the value will always be the result of the application
of the supplied function to a current value, atomically. However, because the
function might be called multiple times, it must be free of side effects.</p>
<p>Atoms are an efficient way to represent some state that will never need to be
coordinated with any other, and for which you wish to make synchronous changes.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">value</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Initial value of the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The constructed Atom</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="Prelude_0_Atom_1" class="def">Atom</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>A value<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>bool<span class='generics'>&gt;</span> validator<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude.Concurrency.cs#L316" class="link">Source</a>
<a href="#Prelude_0_Atom_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atoms provide a way to manage shared, synchronous, independent state without
locks.</p>
</div>
<div><p>The intended use of atom is to hold one an immutable data structure. You change
the value by applying a function to the old value. This is done in an atomic
manner by <code>Swap</code>.</p>
<p>Internally, <code>Swap</code> reads the current value, applies the function to it, and
attempts to <code>CompareExchange</code> it in. Since another thread may have changed the
value in the intervening time, it may have to retry, and does so in a spin loop.</p>
<p>The net effect is that the value will always be the result of the application
of the supplied function to a current value, atomically. However, because the
function might be called multiple times, it must be free of side effects.</p>
<p>Atoms are an efficient way to represent some state that will never need to be
coordinated with any other, and for which you wish to make synchronous changes.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">value</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Initial value of the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">validator</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to run on the value after each state change.</p>
<p>If the function returns false for any proposed new state, then the <code>swap</code>
function will return <code>false</code>, else it will return <code>true</code> on successful setting
of the atom's state</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The constructed Atom or None if the validation faled for the initial
<code>value</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<a id="Prelude_0_Atom_2" class="def">Atom</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>M metadata<span class='comma'>, </span>A value<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude.Concurrency.cs#L343" class="link">Source</a>
<a href="#Prelude_0_Atom_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atoms provide a way to manage shared, synchronous, independent state without
locks.</p>
</div>
<div><p>The intended use of atom is to hold one an immutable data structure. You change
the value by applying a function to the old value. This is done in an atomic
manner by <code>Swap</code>.</p>
<p>Internally, <code>Swap</code> reads the current value, applies the function to it, and
attempts to <code>CompareExchange</code> it in. Since another thread may have changed the
value in the intervening time, it may have to retry, and does so in a spin loop.</p>
<p>The net effect is that the value will always be the result of the application
of the supplied function to a current value, atomically. However, because the
function might be called multiple times, it must be free of side effects.</p>
<p>Atoms are an efficient way to represent some state that will never need to be
coordinated with any other, and for which you wish to make synchronous changes.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">metadata</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Metadata to be passed to the validation function</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">value</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Initial value of the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The constructed Atom</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
Option<span class='generics'>&lt;</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span>
<a id="Prelude_0_Atom_2" class="def">Atom</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>M metadata<span class='comma'>, </span>A value<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>bool<span class='generics'>&gt;</span> validator<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude.Concurrency.cs#L377" class="link">Source</a>
<a href="#Prelude_0_Atom_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atoms provide a way to manage shared, synchronous, independent state without
locks.</p>
</div>
<div><p>The intended use of atom is to hold one an immutable data structure. You change
the value by applying a function to the old value. This is done in an atomic
manner by <code>Swap</code>.</p>
<p>Internally, <code>Swap</code> reads the current value, applies the function to it, and
attempts to <code>CompareExchange</code> it in. Since another thread may have changed the
value in the intervening time, it may have to retry, and does so in a spin loop.</p>
<p>The net effect is that the value will always be the result of the application
of the supplied function to a current value, atomically. However, because the
function might be called multiple times, it must be free of side effects.</p>
<p>Atoms are an efficient way to represent some state that will never need to be
coordinated with any other, and for which you wish to make synchronous changes.</p>
</div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">metadata</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Metadata to be passed to the validation function</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">value</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Initial value of the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">validator</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to run on the value after each state change.</p>
<p>If the function returns false for any proposed new state, then the <code>swap</code>
function will return <code>false</code>, else it will return <code>true</code> on successful setting
of the atom's state</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>The constructed Atom or None if the validation faled for the initial
<code>value</code></p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
A
<a id="Prelude_0_swap_1" class="def">swap</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude.Concurrency.cs#L394" class="link">Source</a>
<a href="#Prelude_0_swap_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>If the swap operation succeeded then a snapshot of the value that was set is returned.
If the swap operation fails (which can only happen due to its validator returning false),
then a snapshot of the current value within the Atom is returned.
If there is no validator for the Atom then the return value is always the snapshot of
the successful <code>f</code> function.</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
A
<a id="Prelude_0_swap_1" class="def">swap</a>
<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>A<span class='comma'>, </span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude.Concurrency.cs#L412" class="link">Source</a>
<a href="#Prelude_0_swap_1" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><ul>
<li class='markdown-bullet'>If <code>f</code> returns <code>None</code> then no update occurs and the result of the call
to <code>Swap</code> will be the latest (unchanged) value of <code>A</code>.</li>
<li class='markdown-bullet'>If the swap operation fails, due to its validator returning false, then a snapshot of
the current value within the Atom is returned.</li>
<li class='markdown-bullet'>If the swap operation succeeded then a snapshot of the value that was set is returned.</li>
<li class='markdown-bullet'>If there is no validator for the Atom then the return value is always the snapshot of
the successful <code>f</code> function.</li>
</ul>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
A
<a id="Prelude_0_swap_2" class="def">swap</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>A<span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude.Concurrency.cs#L428" class="link">Source</a>
<a href="#Prelude_0_swap_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><p>If the swap operation succeeded then a snapshot of the value that was set is returned.
If the swap operation fails (which can only happen due to its validator returning false),
then a snapshot of the current value within the Atom is returned.
If there is no validator for the Atom then the return value is always the snapshot of
the successful <code>f</code> function.</p>
</span></td></tr></tbody></table></div></div>
</div>












</div>
<div class="top"><p class="src"><span class="keyword">method</span>
A
<a id="Prelude_0_swap_2" class="def">swap</a>
<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span>
<span class='parens'>(</span>Atom<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='generics'>&gt;</span> ma<span class='comma'>, </span>Func<span class='generics'>&lt;</span>M<span class='comma'>, </span>A<span class='comma'>, </span>Option<span class='generics'>&lt;</span>A<span class='generics'>&gt;</span><span class='generics'>&gt;</span> f<span class='parens'>)</span>
<a href="https://github.com/louthy/language-ext/tree/main/LanguageExt.Core/Concurrency/Prelude.Concurrency.cs#L446" class="link">Source</a>
<a href="#Prelude_0_swap_2" class="selflink">#</a>
<div class="constraints"></div></p>
<div class="doc"><div><p>Atomically updates the value by passing the old value to <code>f</code> and updating
the atom with the result.  Note: <code>f</code> may be called multiple times, so it
should be free of side effects.</p>
</div>
<div></div>
<div class="methods"><p class="caption">Parameters</p>
<div class="params-and-returns"><table><tbody><tr><td class="src clearfix"><span class="keyword">param</span></td>
<td class="src clearfix"><span class="inst-left"><span class="def">f</span></span></td>
<td class="src clearfix"><span class="instruction inst-left"><p>Function to update the atom</p>
</span></td></tr>
<tr><td class="src clearfix"><span class="keyword">returns</span></td>
<td colspan="2" class="src clearfix"><span class="instruction inst-left"><ul>
<li class='markdown-bullet'>If <code>f</code> returns <code>None</code> then no update occurs and the result of the call
to <code>Swap</code> will be the latest (unchanged) value of <code>A</code>.</li>
<li class='markdown-bullet'>If the swap operation fails, due to its validator returning false, then a snapshot of
the current value within the Atom is returned.</li>
<li class='markdown-bullet'>If the swap operation succeeded then a snapshot of the value that was set is returned.</li>
<li class='markdown-bullet'>If there is no validator for the Atom then the return value is always the snapshot of
the successful <code>f</code> function.</li>
</ul>
</span></td></tr></tbody></table></div></div>
</div>












</div></div>




</div></div></div></body></html>